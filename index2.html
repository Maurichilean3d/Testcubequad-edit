<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Blender Lite - Robust Quad</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #222; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        
        /* UI FLOTANTE */
        .toolbar-container {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 12px; background: rgba(30,30,30,0.95); padding: 12px 20px;
            border-radius: 16px; border: 1px solid #444; backdrop-filter: blur(10px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.6); z-index: 100;
        }

        #top-bar { top: 15px; bottom: auto; padding: 8px 12px; }

        .btn {
            width: 44px; height: 44px; border: none; border-radius: 8px; background: #3a3a3a;
            color: #aaa; cursor: pointer; display: flex; align-items: center; justify-content: center;
            transition: 0.2s; position: relative;
        }
        .btn:active { transform: scale(0.95); }
        .btn.active { background: #3498db; color: white; box-shadow: 0 0 12px rgba(52, 152, 219, 0.4); }
        
        .btn svg { width: 24px; height: 24px; fill: currentColor; }

        /* Colores Específicos */
        .btn[data-mode="vertex"].active { background: #e74c3c; }
        .btn[data-mode="edge"].active { background: #f1c40f; color: #111; }
        
        /* Botones de Acción */
        .action-btn { 
            width: auto; padding: 0 16px; height: 48px; font-weight: bold; font-size: 11px; 
            text-transform: uppercase; flex-direction: column; gap: 4px;
        }
        .btn-extrude { color: #f1c40f; }
        .btn-subdiv { color: #2ecc71; }
        .btn-delete { color: #e74c3c; }

        #info-overlay {
            position: absolute; top: 80px; width: 100%; text-align: center;
            color: #666; font-size: 11px; pointer-events: none; text-shadow: 0 1px 2px black;
        }
        
        #warning {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);
            background: rgba(231, 76, 60, 0.9); color: white; padding: 20px;
            border-radius: 10px; display: none; pointer-events: none; font-weight: bold;
        }
    </style>
</head>
<body>

    <div id="info-overlay">Topología Quad Pro • <span id="poly-display">6</span> Caras</div>
    <div id="warning">¡Límite de geometría alcanzado!</div>

    <div id="top-bar" class="toolbar-container">
        <button class="btn active" data-mode="vertex" title="Vértices (Mover)">
            <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="5"/></svg>
        </button>
        <button class="btn" data-mode="edge" title="Bordes (Mover)">
            <svg viewBox="0 0 24 24"><path d="M4 20L20 4" stroke="currentColor" stroke-width="4" stroke-linecap="round"/></svg>
        </button>
        <button class="btn" data-mode="face" title="Caras (Seleccionar)">
            <svg viewBox="0 0 24 24"><rect x="5" y="5" width="14" height="14" rx="2"/></svg>
        </button>
    </div>

    <div class="toolbar-container">
        <button class="btn action-btn btn-extrude" id="btn-extrude">
            <svg viewBox="0 0 24 24" style="width:20px"><path d="M4 4h16v16H4z M8 8h8v8H8z"/></svg> Extruir
        </button>
        <button class="btn action-btn btn-subdiv" id="btn-subdivide">
            <svg viewBox="0 0 24 24" style="width:20px"><path d="M3 3h18v18H3z M12 3v18 M3 12h18"/></svg> Dividir
        </button>
        <div style="width:1px; background:#555; margin:0 5px;"></div>
        <button class="btn action-btn btn-delete" id="btn-delete">
            <svg viewBox="0 0 24 24" style="width:20px"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg> Borrar
        </button>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://ga.jspm.io/npm:three@0.160.0/build/three.module.js",
            "three/addons/": "https://ga.jspm.io/npm:three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';

        // ==========================================
        // 1. MOTOR QUAD (LÓGICA MATEMÁTICA)
        // ==========================================
        class QuadEngine {
            constructor() {
                this.vertices = []; 
                this.quads = [];    
            }

            initCube() {
                this.vertices = []; this.quads = [];
                const s = 1; 
                const v = [[-s,-s,s],[s,-s,s],[s,s,s],[-s,s,s],[-s,-s,-s],[s,-s,-s],[s,s,-s],[-s,s,-s]];
                v.forEach(p => this.vertices.push(new THREE.Vector3(...p)));
                this.addQuad(0,1,2,3); this.addQuad(5,4,7,6); this.addQuad(1,5,6,2);
                this.addQuad(4,0,3,7); this.addQuad(3,2,6,7); this.addQuad(4,5,1,0);
            }

            addQuad(a,b,c,d) { this.quads.push([a,b,c,d]); }

            // Generar Mesh Visual (Safe Rebuild)
            getRenderData() {
                const positions = [];
                for(let q of this.quads) {
                    const v = q.map(i => this.vertices[i]);
                    // Asegurar que existen los vértices
                    if(!v[0] || !v[1] || !v[2] || !v[3]) continue;
                    // Tri 1
                    positions.push(v[0].x, v[0].y, v[0].z, v[1].x, v[1].y, v[1].z, v[2].x, v[2].y, v[2].z);
                    // Tri 2
                    positions.push(v[0].x, v[0].y, v[0].z, v[2].x, v[2].y, v[2].z, v[3].x, v[3].y, v[3].z);
                }
                return new Float32Array(positions);
            }

            getWireframeData() {
                const positions = [];
                for(let q of this.quads) {
                    const v = q.map(i => this.vertices[i]);
                    if(!v[0]) continue;
                    for(let i=0; i<4; i++) {
                        const vCurr = v[i];
                        const vNext = v[(i+1)%4];
                        if(!vCurr || !vNext) continue;
                        positions.push(vCurr.x, vCurr.y, vCurr.z);
                        positions.push(vNext.x, vNext.y, vNext.z);
                    }
                }
                return new Float32Array(positions);
            }

            // --- SUBDIVISIÓN SEGURA ---
            subdivide() {
                // Límite de seguridad para evitar cuelgues del navegador
                if(this.quads.length > 2000) {
                    document.getElementById('warning').style.display = 'block';
                    setTimeout(() => document.getElementById('warning').style.display = 'none', 2000);
                    return;
                }

                const newQuads = [];
                const edgeCache = new Map();

                // Función auxiliar para obtener punto medio (con caché)
                const getMid = (i1, i2) => {
                    const key = i1<i2 ? `${i1}_${i2}` : `${i2}_${i1}`;
                    if(edgeCache.has(key)) return edgeCache.get(key);
                    
                    const v1 = this.vertices[i1];
                    const v2 = this.vertices[i2];
                    if(!v1 || !v2) return null;
                    
                    const mid = new THREE.Vector3().addVectors(v1, v2).multiplyScalar(0.5);
                    
                    this.vertices.push(mid);
                    const idx = this.vertices.length-1;
                    edgeCache.set(key, idx);
                    return idx;
                };

                for(let q of this.quads) {
                    // Validar que todos los índices sean válidos
                    if(q.some(i => i >= this.vertices.length || !this.vertices[i])) continue;
                    
                    // Centro de la cara
                    const v = q.map(i => this.vertices[i]);
                    const centerPos = new THREE.Vector3().add(v[0]).add(v[1]).add(v[2]).add(v[3]).multiplyScalar(0.25);
                    
                    this.vertices.push(centerPos);
                    const cIdx = this.vertices.length - 1;

                    // Medios de bordes
                    const m01 = getMid(q[0], q[1]);
                    const m12 = getMid(q[1], q[2]);
                    const m23 = getMid(q[2], q[3]);
                    const m30 = getMid(q[3], q[0]);

                    if(m01 === null || m12 === null || m23 === null || m30 === null) continue;

                    // Generar 4 hijos
                    newQuads.push([q[0], m01, cIdx, m30]);
                    newQuads.push([m01, q[1], m12, cIdx]);
                    newQuads.push([cIdx, m12, q[2], m23]);
                    newQuads.push([m30, cIdx, m23, q[3]]);
                }
                this.quads = newQuads;
            }

            extrudeFace(index) {
                if(index < 0 || index >= this.quads.length) return;
                const q = this.quads[index];
                
                // Validar índices
                if(q.some(i => i >= this.vertices.length || !this.vertices[i])) return;
                
                // Calcular normal
                const v = q.map(i => this.vertices[i]);
                const vA = new THREE.Vector3().subVectors(v[1], v[0]);
                const vB = new THREE.Vector3().subVectors(v[3], v[0]);
                const normal = new THREE.Vector3().crossVectors(vA, vB).normalize();
                
                // Crear 4 nuevos vértices
                const topIndices = [];
                const dist = 0.5;

                for(let i=0; i<4; i++) {
                    const newPos = v[i].clone().add(normal.clone().multiplyScalar(dist));
                    this.vertices.push(newPos);
                    topIndices.push(this.vertices.length-1);
                }

                // Caras laterales
                const base = [...q];
                for(let i=0; i<4; i++) {
                    const next = (i+1)%4;
                    this.addQuad(base[i], base[next], topIndices[next], topIndices[i]);
                }

                // Tapa
                this.quads[index] = topIndices;
                return index;
            }

            deleteFace(index) {
                if(index > -1 && index < this.quads.length) this.quads.splice(index, 1);
            }
        }

        // ==========================================
        // 2. ESCENA & RENDER
        // ==========================================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);
        scene.add(new THREE.GridHelper(20, 20, 0x444444, 0x333333));

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(5, 5, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const light = new THREE.DirectionalLight(0xffffff, 1.5);
        light.position.set(5, 10, 7);
        scene.add(light, new THREE.AmbientLight(0xffffff, 0.5));

        // --- MESH PRINCIPAL ---
        const engine = new QuadEngine();
        engine.initCube();

        // Creamos Mesh vacío inicialmente
        let mainMesh = new THREE.Mesh(new THREE.BufferGeometry(), new THREE.MeshStandardMaterial({ 
            color: 0x7f8c8d, roughness: 0.5, metalness: 0.1, polygonOffset: true, polygonOffsetFactor: 1 
        }));
        scene.add(mainMesh);

        let wireMesh = new THREE.LineSegments(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ color: 0x111111, opacity: 0.5, transparent: true }));
        scene.add(wireMesh);

        // --- SISTEMA VISUALIZACIÓN SEGURO ---
        function updateScene() {
            // 1. REGENERAR GEOMETRÍA TOTALMENTE (Evita glitches de buffer)
            mainMesh.geometry.dispose();
            wireMesh.geometry.dispose();

            const renderData = engine.getRenderData();
            const wireData = engine.getWireframeData();

            const newMainGeo = new THREE.BufferGeometry();
            newMainGeo.setAttribute('position', new THREE.BufferAttribute(renderData, 3));
            newMainGeo.computeVertexNormals();
            mainMesh.geometry = newMainGeo;

            const newWireGeo = new THREE.BufferGeometry();
            newWireGeo.setAttribute('position', new THREE.BufferAttribute(wireData, 3));
            wireMesh.geometry = newWireGeo;

            document.getElementById('poly-display').innerText = engine.quads.length;
        }

        // --- HANDLES (GIZMOS) ---
        const helperGroup = new THREE.Group();
        scene.add(helperGroup);
        let currentMode = 'vertex';
        let selection = null;

        function rebuildHandles() {
            helperGroup.clear();
            selection = null;
            transform.detach();

            // Límite de Handles para rendimiento
            if(engine.vertices.length > 3000) {
                // Si hay demasiados vértices, solo mostramos handles en modo cara para evitar lag
                if(currentMode !== 'face') return; 
            }

            if(currentMode === 'vertex') {
                const geo = new THREE.SphereGeometry(0.1);
                const mat = new THREE.MeshBasicMaterial({ color: 0xe74c3c });
                engine.vertices.forEach((v, i) => {
                    if(!v) return;
                    const h = new THREE.Mesh(geo, mat);
                    h.position.copy(v);
                    h.userData = { type: 'vertex', index: i };
                    helperGroup.add(h);
                });
            } else if (currentMode === 'face') {
                const geo = new THREE.PlaneGeometry(0.2, 0.2);
                const mat = new THREE.MeshBasicMaterial({ color: 0x3498db, side: THREE.DoubleSide, depthTest: false });
                
                engine.quads.forEach((q, i) => {
                    // Validar que todos los vértices existen
                    if(q.some(idx => idx >= engine.vertices.length || !engine.vertices[idx])) return;
                    
                    const center = new THREE.Vector3();
                    q.forEach(idx => center.add(engine.vertices[idx]));
                    center.multiplyScalar(0.25);
                    
                    // Orientar handle hacia la normal
                    const v0 = engine.vertices[q[0]];
                    const v1 = engine.vertices[q[1]];
                    const v2 = engine.vertices[q[3]];
                    const n = new THREE.Vector3().subVectors(v1, v0).cross(new THREE.Vector3().subVectors(v2, v0)).normalize();

                    const h = new THREE.Mesh(geo, mat);
                    h.position.copy(center);
                    h.lookAt(center.clone().add(n));
                    h.userData = { type: 'face', index: i };
                    helperGroup.add(h);
                });
            } else if (currentMode === 'edge') {
                const geo = new THREE.BoxGeometry(0.05, 0.05, 1);
                const mat = new THREE.MeshBasicMaterial({ color: 0xf1c40f });
                const processed = new Set();

                engine.quads.forEach(q => {
                    for(let k=0; k<4; k++) {
                        const i1 = q[k];
                        const i2 = q[(k+1)%4];
                        
                        // Validar índices
                        if(i1 >= engine.vertices.length || i2 >= engine.vertices.length) continue;
                        if(!engine.vertices[i1] || !engine.vertices[i2]) continue;
                        
                        const key = i1<i2 ? `${i1}_${i2}` : `${i2}_${i1}`;
                        if(processed.has(key)) continue;
                        processed.add(key);

                        const v1 = engine.vertices[i1];
                        const v2 = engine.vertices[i2];
                        const dist = v1.distanceTo(v2);
                        
                        const h = new THREE.Mesh(geo, mat);
                        h.position.copy(v1).add(v2).multiplyScalar(0.5);
                        h.lookAt(v2);
                        h.scale.z = dist * 0.6;
                        h.userData = { type: 'edge', v1: i1, v2: i2 };
                        helperGroup.add(h);
                    }
                });
            }
        }

        // ==========================================
        // 3. CONTROL Y EVENTOS
        // ==========================================
        const orbit = new OrbitControls(camera, renderer.domElement);
        orbit.enableDamping = true;
        const transform = new TransformControls(camera, renderer.domElement);
        transform.setSpace('local');
        transform.addEventListener('dragging-changed', e => orbit.enabled = !e.value);
        scene.add(transform);

        // --- MOVIMIENTO ---
        transform.addEventListener('objectChange', () => {
            const h = transform.object;
            if(!h || !h.userData) return;
            
            const type = h.userData.type;

            if(type === 'vertex') {
                if(h.userData.index < engine.vertices.length) {
                    engine.vertices[h.userData.index].copy(h.position);
                }
            } else if (type === 'edge') {
                const v1Idx = h.userData.v1;
                const v2Idx = h.userData.v2;
                
                if(v1Idx >= engine.vertices.length || v2Idx >= engine.vertices.length) return;
                
                const v1 = engine.vertices[v1Idx];
                const v2 = engine.vertices[v2Idx];
                const dist = v1.distanceTo(v2);
                const dir = new THREE.Vector3().subVectors(v2, v1).normalize();
                v1.copy(h.position).addScaledVector(dir, -dist/2);
                v2.copy(h.position).addScaledVector(dir, dist/2);
            }
            updateScene();
        });

        transform.addEventListener('mouseUp', () => {
            if(currentMode !== 'vertex') rebuildHandles();
        });

        // --- UI ---
        function setMode(m) {
            currentMode = m;
            document.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
            const modeBtn = document.querySelector(`.btn[data-mode="${m}"]`);
            if(modeBtn) modeBtn.classList.add('active');
            
            const btnExtrude = document.getElementById('btn-extrude');
            const btnDelete = document.getElementById('btn-delete');
            
            if(m === 'face') {
                btnExtrude.style.opacity = 1; 
                btnDelete.style.opacity = 1;
            } else {
                btnExtrude.style.opacity = 0.3;
                btnDelete.style.opacity = 0.3;
            }

            rebuildHandles();
            updateScene();
        }

        document.querySelectorAll('.btn[data-mode]').forEach(b => b.onclick = () => setMode(b.dataset.mode));

        // ACCIONES
        document.getElementById('btn-extrude').onclick = () => {
            if(currentMode === 'face' && selection) {
                engine.extrudeFace(selection.userData.index);
                updateScene();
                rebuildHandles();
            }
        };

        document.getElementById('btn-subdivide').onclick = () => {
            transform.detach();
            engine.subdivide();
            updateScene();
            rebuildHandles();
        };

        document.getElementById('btn-delete').onclick = () => {
            if(currentMode === 'face' && selection) {
                engine.deleteFace(selection.userData.index);
                transform.detach();
                updateScene();
                rebuildHandles();
            }
        };

        // --- RAYCASTER ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.addEventListener('pointerdown', e => {
            if(e.target.closest('.toolbar') || e.target.closest('.toolbar-container')) return;

            const r = renderer.domElement.getBoundingClientRect();
            mouse.x = ((e.clientX - r.left)/r.width)*2-1;
            mouse.y = -((e.clientY - r.top)/r.height)*2+1;
            raycaster.setFromCamera(mouse, camera);

            const hits = raycaster.intersectObjects(helperGroup.children);
            if(hits.length > 0) {
                selection = hits[0].object;
                transform.attach(selection);
                
                helperGroup.children.forEach(c => {
                    let col = 0xffffff;
                    if(c.userData.type === 'vertex') col = 0xe74c3c;
                    if(c.userData.type === 'edge') col = 0xf1c40f;
                    if(c.userData.type === 'face') col = 0x3498db;
                    c.material.color.setHex(col);
                });
                selection.material.color.setHex(0xffffff);
            } else if (!transform.dragging) {
                transform.detach();
                selection = null;
            }
        });

        // INIT
        updateScene();
        rebuildHandles();

        function animate() {
            requestAnimationFrame(animate);
            orbit.update();
            renderer.render(scene, camera);
        }
        animate();

        window.onresize = () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };
    </script>
</body>
</html>
