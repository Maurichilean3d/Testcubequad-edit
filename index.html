<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>True Quad Editor</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #222; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        
        /* UI FLOTANTE */
        #toolbar {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 15px; background: rgba(30,30,30,0.9); padding: 15px 25px;
            border-radius: 16px; border: 1px solid #444; backdrop-filter: blur(10px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        .tool-btn {
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            width: 60px; height: 60px; background: #3a3a3a; border: none; border-radius: 12px;
            color: #ccc; cursor: pointer; transition: 0.2s;
        }
        .tool-btn:active { transform: scale(0.95); background: #222; }
        
        .tool-btn svg { width: 28px; height: 28px; margin-bottom: 4px; fill: currentColor; }
        .label { font-size: 10px; font-weight: bold; text-transform: uppercase; }

        .btn-extrude { color: #f1c40f; }
        .btn-subdiv { color: #3498db; }
        .btn-reset { color: #e74c3c; }

        #info {
            position: absolute; top: 20px; width: 100%; text-align: center;
            color: #666; font-size: 12px; pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="info">Motor de Topología Quad v1.0 • <span id="poly-count">6</span> Quads</div>

    <div id="toolbar">
        <button class="tool-btn btn-extrude" id="btn-extrude">
            <svg viewBox="0 0 24 24"><path d="M4 4h16v16H4z M8 8h8v8H8z"/></svg>
            <span class="label">Extruir</span>
        </button>
        <button class="tool-btn btn-subdiv" id="btn-subdivide">
            <svg viewBox="0 0 24 24"><path d="M3 3h18v18H3z M12 3v18 M3 12h18"/></svg>
            <span class="label">Dividir</span>
        </button>
        <button class="tool-btn btn-reset" id="btn-reset">
            <svg viewBox="0 0 24 24"><path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z"/></svg>
            <span class="label">Reset</span>
        </button>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://ga.jspm.io/npm:three@0.160.0/build/three.module.js",
            "three/addons/": "https://ga.jspm.io/npm:three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';

        // --- 1. CLASE MAESTRA DE GEOMETRÍA QUAD ---
        // Esta clase maneja la lógica pura, separada de Three.js
        class QuadMesh {
            constructor() {
                this.vertices = []; // Array de Vector3
                this.quads = [];    // Array de [v1, v2, v3, v4] indices
            }

            addVertex(x, y, z) {
                this.vertices.push(new THREE.Vector3(x, y, z));
                return this.vertices.length - 1;
            }

            addQuad(a, b, c, d) {
                this.quads.push([a, b, c, d]);
            }

            // Generar el cubo inicial
            initCube() {
                this.vertices = []; this.quads = [];
                // 8 Vértices del cubo
                const s = 1;
                const v = [
                    [-s,-s, s], [ s,-s, s], [ s, s, s], [-s, s, s], // Front (0,1,2,3)
                    [-s,-s,-s], [ s,-s,-s], [ s, s,-s], [-s, s,-s]  // Back (4,5,6,7)
                ];
                v.forEach(p => this.addVertex(p[0], p[1], p[2]));

                // 6 Caras (Orden CCW estricto)
                this.addQuad(0, 1, 2, 3); // Front
                this.addQuad(5, 4, 7, 6); // Back
                this.addQuad(1, 5, 6, 2); // Right
                this.addQuad(4, 0, 3, 7); // Left
                this.addQuad(3, 2, 6, 7); // Top
                this.addQuad(4, 5, 1, 0); // Bottom
            }

            // --- OPERACIÓN: SUBDIVISIÓN (Catmull-Clark Lite) ---
            subdivide() {
                const newQuads = [];
                // Cache de bordes para compartir vértices: clave "min_max" -> indiceVertice
                const edgeCache = new Map();

                // Función auxiliar para obtener/crear punto medio de un borde
                const getEdgeMidpoint = (i1, i2) => {
                    const key = i1 < i2 ? `${i1}_${i2}` : `${i2}_${i1}`;
                    if(edgeCache.has(key)) return edgeCache.get(key);

                    const v1 = this.vertices[i1];
                    const v2 = this.vertices[i2];
                    const mid = new THREE.Vector3().addVectors(v1, v2).multiplyScalar(0.5);
                    const newIdx = this.addVertex(mid.x, mid.y, mid.z);
                    edgeCache.set(key, newIdx);
                    return newIdx;
                };

                // Iterar sobre cada Quad actual y romperlo en 4
                for(let q of this.quads) {
                    const [a, b, c, d] = q;
                    
                    // 1. Calcular Centroide de la cara
                    const centerPos = new THREE.Vector3()
                        .add(this.vertices[a]).add(this.vertices[b])
                        .add(this.vertices[c]).add(this.vertices[d]).multiplyScalar(0.25);
                    const centerIdx = this.addVertex(centerPos.x, centerPos.y, centerPos.z);

                    // 2. Obtener puntos medios de los 4 bordes
                    const mab = getEdgeMidpoint(a, b);
                    const mbc = getEdgeMidpoint(b, c);
                    const mcd = getEdgeMidpoint(c, d);
                    const mda = getEdgeMidpoint(d, a);

                    // 3. Crear 4 nuevos quads conectando esquinas al centro
                    newQuads.push([a, mab, centerIdx, mda]); // Quad inferior-izq (relativo)
                    newQuads.push([mab, b, mbc, centerIdx]); // Quad inferior-der
                    newQuads.push([centerIdx, mbc, c, mcd]); // Quad superior-der
                    newQuads.push([mda, centerIdx, mcd, d]); // Quad superior-izq
                }

                this.quads = newQuads; // Reemplazar topología
            }

            // --- OPERACIÓN: EXTRUSIÓN ---
            extrudeQuad(quadIndex) {
                const q = this.quads[quadIndex]; // Indices [a,b,c,d]
                
                // 1. Calcular Normal promedio
                const va = this.vertices[q[0]];
                const vb = this.vertices[q[1]];
                const vc = this.vertices[q[2]];
                const v1 = new THREE.Vector3().subVectors(vb, va);
                const v2 = new THREE.Vector3().subVectors(vc, vb);
                const normal = new THREE.Vector3().crossVectors(v1, v2).normalize();

                // 2. Crear 4 nuevos vértices desplazados (la "tapa")
                const dist = 0.5; // Distancia extrusión
                const newIndices = [];
                for(let idx of q) {
                    const v = this.vertices[idx];
                    const nv = v.clone().add(normal.clone().multiplyScalar(dist));
                    newIndices.push(this.addVertex(nv.x, nv.y, nv.z));
                }

                // 3. Crear 4 quads laterales (puentes)
                // Lado 1: q0->q1 sube a n1->n0
                this.addQuad(q[0], q[1], newIndices[1], newIndices[0]);
                this.addQuad(q[1], q[2], newIndices[2], newIndices[1]);
                this.addQuad(q[2], q[3], newIndices[3], newIndices[2]);
                this.addQuad(q[3], q[0], newIndices[0], newIndices[3]);

                // 4. ACTUALIZAR el quad original para que sea la "tapa" superior
                // Esto es clave: no borramos el quad viejo, lo "movemos" topológicamente a la cima
                this.quads[quadIndex] = newIndices; 
                
                return quadIndex; // Devolver índice para mantener selección
            }

            // --- CONVERSIÓN A THREE.JS ---
            toBufferGeometry() {
                const geo = new THREE.BufferGeometry();
                const posArr = [];
                const idxArr = []; // Para Wireframe limpio usando edgesGeometry despues no sirve tanto
                // Mejor: Sopa de triángulos no indexada para flat shading correcto
                
                // Convertir cada Quad en 2 Triángulos
                for(let q of this.quads) {
                    const v0 = this.vertices[q[0]];
                    const v1 = this.vertices[q[1]];
                    const v2 = this.vertices[q[2]];
                    const v3 = this.vertices[q[3]];

                    // Tri 1 (0,1,2)
                    posArr.push(v0.x, v0.y, v0.z);
                    posArr.push(v1.x, v1.y, v1.z);
                    posArr.push(v2.x, v2.y, v2.z);

                    // Tri 2 (0,2,3)
                    posArr.push(v0.x, v0.y, v0.z);
                    posArr.push(v2.x, v2.y, v2.z);
                    posArr.push(v3.x, v3.y, v3.z);
                }

                geo.setAttribute('position', new THREE.Float32BufferAttribute(posArr, 3));
                geo.computeVertexNormals();
                return geo;
            }

            // Generar líneas solo para los bordes de los quads (Wireframe limpio)
            getWireframeGeometry() {
                const positions = [];
                for(let q of this.quads) {
                    const v = q.map(i => this.vertices[i]);
                    // 4 líneas del quad
                    for(let i=0; i<4; i++) {
                        positions.push(v[i].x, v[i].y, v[i].z);
                        positions.push(v[(i+1)%4].x, v[(i+1)%4].y, v[(i+1)%4].z);
                    }
                }
                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                return geo;
            }
        }

        // --- 2. CONFIGURACIÓN VISUAL ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);
        scene.add(new THREE.GridHelper(20, 20, 0x444444, 0x333333));

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(5, 5, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const light = new THREE.DirectionalLight(0xffffff, 1.5);
        light.position.set(5, 10, 7);
        scene.add(light, new THREE.AmbientLight(0xffffff, 0.5));

        // --- 3. INSTANCIAR MOTOR ---
        const qMesh = new QuadMesh();
        qMesh.initCube();

        // Malla Visual (Render)
        const material = new THREE.MeshStandardMaterial({ 
            color: 0x7f8c8d, roughness: 0.5, metalness: 0.1,
            polygonOffset: true, polygonOffsetFactor: 1
        });
        let mainMesh = new THREE.Mesh(new THREE.BufferGeometry(), material);
        scene.add(mainMesh);

        // Wireframe Visual
        let wireMesh = new THREE.LineSegments(
            new THREE.BufferGeometry(), 
            new THREE.LineBasicMaterial({ color: 0x111111, opacity: 0.5, transparent: true })
        );
        scene.add(wireMesh); // Añadimos a escena para que no dependa de la malla

        // --- 4. GESTOR DE SELECCIÓN (HANDLES) ---
        const helperGroup = new THREE.Group();
        scene.add(helperGroup);
        let selectedQuadIndex = -1;

        function updateScene() {
            // 1. Actualizar geometría visual
            mainMesh.geometry.dispose();
            mainMesh.geometry = qMesh.toBufferGeometry();

            // 2. Actualizar Wireframe (Lineas Quad Reales)
            wireMesh.geometry.dispose();
            wireMesh.geometry = qMesh.getWireframeGeometry();

            // 3. Regenerar Gizmos de Caras
            helperGroup.clear();
            
            const handleGeo = new THREE.PlaneGeometry(0.3, 0.3);
            const handleMat = new THREE.MeshBasicMaterial({ color: 0x3498db, side: THREE.DoubleSide, depthTest: false, opacity: 0.6, transparent: true });
            const selectedMat = new THREE.MeshBasicMaterial({ color: 0xf1c40f, side: THREE.DoubleSide, depthTest: false });

            qMesh.quads.forEach((q, idx) => {
                // Calcular centroide
                const center = new THREE.Vector3();
                q.forEach(vi => center.add(qMesh.vertices[vi]));
                center.multiplyScalar(0.25);

                // Calcular orientación (Normal)
                const va = qMesh.vertices[q[0]];
                const vb = qMesh.vertices[q[1]];
                const vc = qMesh.vertices[q[2]];
                const norm = new THREE.Vector3().subVectors(vb, va).cross(new THREE.Vector3().subVectors(vc, vb)).normalize();

                const h = new THREE.Mesh(handleGeo, idx === selectedQuadIndex ? selectedMat : handleMat);
                h.position.copy(center);
                h.lookAt(center.clone().add(norm));
                h.userData = { id: idx, type: 'face' };
                
                helperGroup.add(h);
            });

            // Actualizar UI
            document.getElementById('poly-count').innerText = qMesh.quads.length;
        }

        updateScene();

        // --- 5. CONTROLADORES ---
        const orbit = new OrbitControls(camera, renderer.domElement);
        orbit.enableDamping = true;

        const transform = new TransformControls(camera, renderer.domElement);
        transform.setSpace('local');
        transform.addEventListener('dragging-changed', e => orbit.enabled = !e.value);
        scene.add(transform);

        // Movimiento de vértices al mover la cara
        transform.addEventListener('objectChange', () => {
            if(selectedQuadIndex === -1) return;
            const handle = transform.object;
            
            // Lógica simple: Mover los 4 vértices del quad seleccionado
            // Delta = PosActual - PosAnterior? No tenemos anterior.
            // Solución: Recalcular posiciones basadas en offset del centro.
            // Para evitar colapso, regeneramos la geometría visual solo al soltar o usamos delta.
            
            // Para este demo LITE: Solo permitimos selección para Extruir.
            // Mover caras individuales en una malla conectada sin deformar vecinos es complejo.
            // DESACTIVAMOS MOVIMIENTO DIRECTO para priorizar Extrusión limpia.
        });

        // --- 6. EVENTOS DE HERRAMIENTAS ---
        
        // EXTRUIR
        document.getElementById('btn-extrude').onclick = () => {
            if(selectedQuadIndex === -1) { alert("Selecciona una cara"); return; }
            
            qMesh.extrudeQuad(selectedQuadIndex);
            updateScene();
            
            // Recolocar gizmo en la nueva cara (que tiene el mismo índice)
            // Necesitamos buscar el handle nuevo visualmente
            // Hack rápido: seleccionar el handle por índice
            const newHandle = helperGroup.children.find(c => c.userData.id === selectedQuadIndex);
            if(newHandle) transform.attach(newHandle);
        };

        // SUBDIVIDIR
        document.getElementById('btn-subdivide').onclick = () => {
            transform.detach();
            selectedQuadIndex = -1;
            qMesh.subdivide();
            updateScene();
        };

        // RESET
        document.getElementById('btn-reset').onclick = () => {
            transform.detach();
            selectedQuadIndex = -1;
            qMesh.initCube();
            updateScene();
        };

        // RAYCASTER
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.addEventListener('pointerdown', e => {
            if(e.target.closest('button')) return;

            const r = renderer.domElement.getBoundingClientRect();
            mouse.x = ((e.clientX - r.left)/r.width)*2-1;
            mouse.y = -((e.clientY - r.top)/r.height)*2+1;
            ray.setFromCamera(mouse, camera);

            const hits = ray.intersectObjects(helperGroup.children);
            if(hits.length > 0) {
                const h = hits[0].object;
                selectedQuadIndex = h.userData.id;
                transform.attach(h);
                updateScene(); // Para actualizar colores
            } else if (!transform.dragging) {
                transform.detach();
                selectedQuadIndex = -1;
                updateScene();
            }
        });

        function animate() {
            requestAnimationFrame(animate);
            orbit.update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
