<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Web 3D Modeler - Pro UI</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #151515; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        
        /* --- BARRA SUPERIOR (MODOS DE SELECCI√ìN) --- */
        #top-bar {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 8px; background: rgba(30, 30, 30, 0.9);
            padding: 8px; border-radius: 12px; border: 1px solid #444;
            backdrop-filter: blur(5px); pointer-events: auto;
        }

        .mode-btn {
            width: 45px; height: 45px; border: none; border-radius: 8px;
            background: #333; color: #aaa; cursor: pointer; font-size: 20px;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.2s;
        }
        
        .mode-btn:hover { background: #444; color: white; }
        
        /* Colores espec√≠ficos por modo */
        .mode-btn.active[data-mode="vertex"] { background: #e74c3c; color: white; box-shadow: 0 0 10px rgba(231, 76, 60, 0.4); }
        .mode-btn.active[data-mode="edge"] { background: #f1c40f; color: black; box-shadow: 0 0 10px rgba(241, 196, 15, 0.4); }
        .mode-btn.active[data-mode="face"] { background: #3498db; color: white; box-shadow: 0 0 10px rgba(52, 152, 219, 0.4); }

        /* --- UI INFERIOR (DI√ÅLOGO DE SOLDAR) --- */
        #weld-panel {
            position: absolute; bottom: -150px; left: 0; width: 100%;
            background: #2c3e50; color: white; border-top: 4px solid #2ecc71;
            padding: 20px 0; transition: bottom 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            box-shadow: 0 -5px 20px rgba(0,0,0,0.5); z-index: 100;
        }
        
        #weld-panel.visible { bottom: 0; }

        .weld-controls { display: flex; gap: 20px; margin-top: 15px; }
        
        .action-btn {
            padding: 12px 30px; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; font-size: 1rem;
        }
        .btn-yes { background: #2ecc71; color: white; }
        .btn-no { background: #e74c3c; color: white; }

        /* Iconos SVG simples */
        .icon { width: 24px; height: 24px; fill: currentColor; }
        
        /* Tips */
        #hint {
            position: absolute; bottom: 20px; width: 100%; text-align: center;
            color: #666; font-size: 12px; pointer-events: none; transition: opacity 0.2s;
        }
    </style>
</head>
<body>

    <div id="top-bar">
        <button class="mode-btn active" data-mode="vertex" title="V√©rtices">
            <svg class="icon" viewBox="0 0 24 24"><circle cx="12" cy="12" r="6"/></svg>
        </button>
        <button class="mode-btn" data-mode="edge" title="Bordes">
             <svg class="icon" viewBox="0 0 24 24"><path d="M4 20L20 4" stroke="currentColor" stroke-width="4" stroke-linecap="round"/></svg>
        </button>
        <button class="mode-btn" data-mode="face" title="Caras">
             <svg class="icon" viewBox="0 0 24 24"><rect x="4" y="4" width="16" height="16" rx="2"/></svg>
        </button>
    </div>

    <div id="hint">Toca un elemento para editar</div>

    <div id="weld-panel">
        <div style="font-size: 1.1rem; font-weight: 600;">üîó ¬øSoldar v√©rtices cercanos?</div>
        <div class="weld-controls">
            <button class="action-btn btn-yes" id="btn-weld-yes">S√ç, UNIR</button>
            <button class="action-btn btn-no" id="btn-weld-no">CANCELAR</button>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';

        // --- 1. SETUP ESCENA ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x151515);
        scene.add(new THREE.GridHelper(30, 30, 0x333333, 0x222222));

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(5, 4, 6);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const light = new THREE.DirectionalLight(0xffffff, 1.5);
        light.position.set(5, 10, 7);
        scene.add(light, new THREE.AmbientLight(0xffffff, 0.5));

        // --- 2. GEOMETR√çA BASE ---
        let geometry = new THREE.BoxGeometry(2, 2, 2).toNonIndexed();
        const material = new THREE.MeshStandardMaterial({
            color: 0x555555, roughness: 0.5, metalness: 0.1,
            polygonOffset: true, polygonOffsetFactor: 1, polygonOffsetUnits: 1
        });
        const cube = new THREE.Mesh(geometry, material);
        scene.add(cube);

        // Wireframe visual
        let wireframe = new THREE.LineSegments(
            new THREE.EdgesGeometry(geometry),
            new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 })
        );
        cube.add(wireframe);

        // --- 3. GESTOR DE ELEMENTOS (HANDLES) ---
        const helpersGroup = new THREE.Group();
        scene.add(helpersGroup);
        
        // Almacenes de controladores
        let vertexHandles = [];
        let edgeHandles = [];
        let faceHandles = [];
        
        // Mapeos: Handle -> Indices de v√©rtices reales
        let mapVertex = [];
        let mapEdge = [];
        let mapFace = [];

        // Definici√≥n de Topolog√≠a del Cubo (Hardcoded para estabilidad inicial)
        // 8 esquinas que controlan todo
        // Indices aproximados basados en la construcci√≥n de BoxGeometry no indexado
        // Esto es una simplificaci√≥n: en una app real se calcula din√°micamente.
        function generateHelpers() {
            helpersGroup.clear();
            vertexHandles = []; edgeHandles = []; faceHandles = [];
            mapVertex = []; mapEdge = []; mapFace = [];

            const pos = geometry.attributes.position;
            const size = 0.15; // Tama√±o base handles

            // 1. GENERAR VERTICES (8 Esquinas)
            // Agrupamos v√©rtices geom√©tricamente id√©nticos
            const corners = {}; // Key: "x,y,z" -> [indices]
            for(let i=0; i<pos.count; i++){
                const key = `${pos.getX(i).toFixed(2)},${pos.getY(i).toFixed(2)},${pos.getZ(i).toFixed(2)}`;
                if(!corners[key]) corners[key] = [];
                corners[key].push(i);
            }

            // Crear esferas para Vertices
            let cIdx = 0;
            const vGeo = new THREE.SphereGeometry(size);
            const vMat = new THREE.MeshBasicMaterial({ color: 0xe74c3c, depthTest: false }); // Rojo
            
            Object.values(corners).forEach(indices => {
                const i = indices[0];
                const mesh = new THREE.Mesh(vGeo, vMat.clone());
                mesh.position.set(pos.getX(i), pos.getY(i), pos.getZ(i));
                mesh.userData = { type: 'vertex', id: cIdx };
                mesh.renderOrder = 999;
                
                helpersGroup.add(mesh);
                vertexHandles.push(mesh);
                mapVertex[cIdx] = indices;
                cIdx++;
            });

            // 2. GENERAR BORDES (Conectan 2 corners)
            // Buscamos pares de corners que compartan un eje (alineados) y disten 2 unidades (tama√±o cubo)
            // Ojo: Esto asume cubo inicial. Si se deforma, la l√≥gica se mantiene por los √≠ndices guardados.
            let eIdx = 0;
            const eGeo = new THREE.BoxGeometry(size/2, size/2, 1); // Helper forma alargada gen√©rica
            const eMat = new THREE.MeshBasicMaterial({ color: 0xf1c40f, depthTest: false }); // Amarillo

            // Simplificaci√≥n: Generamos bordes basados en la proximidad de los vertexHandles generados
            for(let i=0; i<vertexHandles.length; i++) {
                for(let j=i+1; j<vertexHandles.length; j++) {
                    const v1 = vertexHandles[i];
                    const v2 = vertexHandles[j];
                    const dist = v1.position.distanceTo(v2.position);
                    
                    // Si est√°n conectados (en un cubo de 2x2x2, bordes miden 2, diagonales 2.82)
                    // Usamos un rango tolerante por si se deform√≥ un poco
                    if(dist > 0.1 && dist < 2.1) {
                        // Crear handle en el medio
                        const mid = new THREE.Vector3().addVectors(v1.position, v2.position).multiplyScalar(0.5);
                        
                        // Rotar el helper para que siga la l√≠nea
                        const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.08, dist), eMat.clone());
                        mesh.position.copy(mid);
                        mesh.lookAt(v2.position);
                        
                        mesh.userData = { type: 'edge', id: eIdx, v1: i, v2: j }; // Guarda IDs de los vertexHandles que controla
                        mesh.renderOrder = 998;
                        
                        helpersGroup.add(mesh);
                        edgeHandles.push(mesh);
                        eIdx++;
                    }
                }
            }

            // 3. GENERAR CARAS (Centros)
            // Una cara tiene 4 v√©rtices coplanares
            // En BoxGeometry, las caras son f√°ciles de detectar por normales, pero aqu√≠ usaremos centros.
            // Para simplificar: caras son agrupaciones de 4 v√©rtices handles.
            // Estrategia robusta: Usar los normales de la geometr√≠a original para colocar el handle.
            // Un cubo tiene 6 caras.
            const faceNormals = [
                new THREE.Vector3(1,0,0), new THREE.Vector3(-1,0,0),
                new THREE.Vector3(0,1,0), new THREE.Vector3(0,-1,0),
                new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,-1)
            ];

            const fMat = new THREE.MeshBasicMaterial({ color: 0x3498db, depthTest: false, transparent: true, opacity: 0.8 }); // Azul
            const fGeo = new THREE.PlaneGeometry(0.5, 0.5);

            faceNormals.forEach((normal, idx) => {
                // Encontrar vertices que coinciden con esta cara
                // (Ej: normal (1,0,0) -> vertices con x > 0)
                const faceVertsIDs = [];
                vertexHandles.forEach((vh, vID) => {
                    // Producto punto para saber si el vertice est√° en la direcci√≥n de la normal
                    // Como es un cubo centrado en 0,0,0 de tama√±o 2...
                    const dir = vh.position.clone().normalize();
                    // Aproximaci√≥n simple para cubo inicial
                    if(Math.abs(vh.position.dot(normal) - 1) < 0.1 || Math.abs(vh.position.dot(normal) - 2) < 0.1 ) { // Ajuste por deformaci√≥n
                        // Logica de backup: buscar centro
                    }
                });

                // METODO ALTERNATIVO ROBUSTO:
                // Simplemente poner 6 handles fijos inicialmente vinculados a los 4 vertices mas cercanos
                const center = normal.clone(); // Posicion inicial de la cara (1,0,0 etc)
                
                // Buscar los 4 handles m√°s cercanos a este centro
                const sortedHandles = vertexHandles.map((v, i) => ({ dist: v.position.distanceTo(center), id: i }))
                                                   .sort((a, b) => a.dist - b.dist);
                
                const closest4 = sortedHandles.slice(0, 4).map(o => o.id);
                
                const mesh = new THREE.Mesh(fGeo, fMat.clone());
                mesh.position.copy(center);
                mesh.lookAt(center.clone().add(normal)); // Orientar hacia afuera
                mesh.userData = { type: 'face', id: idx, vertIDs: closest4 };
                
                helpersGroup.add(mesh);
                faceHandles.push(mesh);
            });
        }

        generateHelpers();

        // --- 4. CONTROL DE MODOS ---
        let currentMode = 'vertex'; // vertex, edge, face
        
        function setMode(mode) {
            currentMode = mode;
            transform.detach();
            document.getElementById('hint').style.opacity = '1';
            
            // UI Update
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            document.querySelector(`.mode-btn[data-mode="${mode}"]`).classList.add('active');

            // Visibilidad
            vertexHandles.forEach(h => h.visible = (mode === 'vertex'));
            edgeHandles.forEach(h => h.visible = (mode === 'edge'));
            faceHandles.forEach(h => h.visible = (mode === 'face'));
        }

        // Listeners UI superior
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', () => setMode(btn.dataset.mode));
        });
        
        // Iniciar en vertex
        setMode('vertex');


        // --- 5. LOGICA DE TRANSFORMACION ---
        const orbit = new OrbitControls(camera, renderer.domElement);
        orbit.enableDamping = true;
        
        const transform = new TransformControls(camera, renderer.domElement);
        transform.setSpace('local');
        transform.setSize(1.2);
        scene.add(transform);

        // Variables de estado para movimiento relativo
        let startPos = new THREE.Vector3();
        let relativeOffsets = []; // Para mover grupos

        transform.addEventListener('dragging-changed', (e) => {
            orbit.enabled = !e.value;
            if(e.value) {
                // START DRAG
                startPos.copy(transform.object.position);
                document.getElementById('hint').style.opacity = '0';
            } else {
                // END DRAG
                if(currentMode === 'vertex') checkWeld(transform.object);
            }
        });

        transform.addEventListener('objectChange', () => {
            const handle = transform.object;
            const type = handle.userData.type;

            if(type === 'vertex') {
                updateGeometryFromVertex(handle);
                // Si movemos un vertice, hay que actualizar la posicion de los edges y faces conectados
                updateHelperPositions(); 
            } else if (type === 'edge') {
                // Mover Borde: movemos los 2 v√©rtices que lo componen
                const v1 = vertexHandles[handle.userData.v1];
                const v2 = vertexHandles[handle.userData.v2];
                
                // Calculamos delta desde el centro del borde
                // Truco: recalculamos las posiciones de v1 y v2 bas√°ndonos en el offset
                // Simplificaci√≥n: Mover v1 y v2 la misma cantidad que se movi√≥ el handle
                // Pero necesitamos el delta frame a frame? No, TransformControls mueve el objeto absoluto.
                
                // Estrategia: Calcular nueva posici√≥n de v1 y v2 relativa al handle
                // Pero el handle ya se movi√≥.
                // Mejor: Al iniciar drag, guardamos offset. Aca, aplicamos.
                // SOLUCI√ìN SIMPLE: Recalcular posiciones.
                // El handle est√° en el centro.
                
                // No podemos inferir rotaci√≥n f√°cilmente solo con posici√≥n, asi que asumimos traslaci√≥n pura por ahora
                // Delta = PosActual - PosAnterior (Dif√≠cil de obtener sin variables globales)
                
                // REENFOQUE:
                // Mover los v√©rtices subyacentes usando el desplazamiento del handle es complejo.
                // Lo haremos al rev√©s: El handle es el "Jefe".
                // Pero el handle representa el promedio.
                // Vamos a usar una l√≥gica de Delta simple.
                
                // NO IMPLEMENTADO COMPLEJO EN ESTA DEMO PARA EVITAR BUGS.
                // SOLO MOVEREMOS VERTICES DIRECTOS EN ESTA VERSION PARA GARANTIZAR ESTABILIDAD
                // O implementar un "Parenting" temporal.
                
                // Implementaci√≥n de movimiento de grupo simple:
                // Al detectar cambio, calculamos la diferencia entre la pos actual del handle y donde deber√≠a estar (promedio de v1 y v2)
                const currentMid = new THREE.Vector3().addVectors(v1.position, v2.position).multiplyScalar(0.5);
                const delta = new THREE.Vector3().subVectors(handle.position, currentMid);
                
                v1.position.add(delta);
                v2.position.add(delta);
                
                updateGeometryFromVertex(v1);
                updateGeometryFromVertex(v2);
                updateHelperPositions(handle); // Actualizar los dem√°s helpers excepto este
                
            } else if (type === 'face') {
                // Mover Cara: Mover los 4 v√©rtices
                const vIDs = handle.userData.vertIDs;
                
                // Calcular centro actual de los 4 vertices
                let currentCenter = new THREE.Vector3();
                vIDs.forEach(id => currentCenter.add(vertexHandles[id].position));
                currentCenter.divideScalar(vIDs.length);
                
                const delta = new THREE.Vector3().subVectors(handle.position, currentCenter);
                
                vIDs.forEach(id => {
                    const v = vertexHandles[id];
                    v.position.add(delta);
                    updateGeometryFromVertex(v);
                });
                updateHelperPositions(handle);
            }
        });

        function updateGeometryFromVertex(vHandle) {
            const realIndices = mapVertex[vHandle.userData.id];
            realIndices.forEach(idx => {
                geometry.attributes.position.setXYZ(idx, vHandle.position.x, vHandle.position.y, vHandle.position.z);
            });
            geometry.attributes.position.needsUpdate = true;
            updateWireframe();
        }

        function updateHelperPositions(excludeHandle = null) {
            // Actualizar Edges
            edgeHandles.forEach(eh => {
                if(eh === excludeHandle) return;
                const v1 = vertexHandles[eh.userData.v1].position;
                const v2 = vertexHandles[eh.userData.v2].position;
                eh.position.copy(v1).add(v2).multiplyScalar(0.5);
                eh.lookAt(v2);
                // Escalar el largo del helper para que coincida visualmente
                const dist = v1.distanceTo(v2);
                eh.scale.z = dist; 
            });

            // Actualizar Faces
            faceHandles.forEach(fh => {
                if(fh === excludeHandle) return;
                const vIDs = fh.userData.vertIDs;
                let center = new THREE.Vector3();
                vIDs.forEach(id => center.add(vertexHandles[id].position));
                center.divideScalar(vIDs.length);
                fh.position.copy(center);
                // Orientaci√≥n de la cara es compleja de actualizar din√°micamente sin recalcular normales, 
                // pero la posici√≥n es lo vital.
            });
        }

        function updateWireframe() {
            cube.remove(wireframe);
            wireframe.geometry.dispose();
            wireframe = new THREE.LineSegments(new THREE.EdgesGeometry(geometry), new THREE.LineBasicMaterial({ color: 0x000000 }));
            cube.add(wireframe);
        }

        // --- 6. SISTEMA DE SOLDADO (WELD UI) ---
        let pendingWeld = null;
        const weldPanel = document.getElementById('weld-panel');

        function checkWeld(handle) {
            const threshold = 0.4;
            let target = null;
            
            // Buscar v√©rtice cercano (excluyendose a s√≠ mismo)
            for(let other of vertexHandles) {
                if(other === handle) continue;
                if(handle.position.distanceTo(other.position) < threshold) {
                    target = other;
                    break;
                }
            }

            if(target) {
                pendingWeld = { active: handle, target: target };
                weldPanel.classList.add('visible'); // MOSTRAR PANEL INFERIOR
            } else {
                weldPanel.classList.remove('visible');
            }
        }

        document.getElementById('btn-weld-yes').onclick = () => {
            if(pendingWeld) {
                const { active, target } = pendingWeld;
                
                // Mover active a target
                active.position.copy(target.position);
                updateGeometryFromVertex(active);
                updateHelperPositions();
                
                // Feedback visual simple (Flash)
                active.material.color.setHex(0x2ecc71);
                setTimeout(() => active.material.color.setHex(0xe74c3c), 500);
            }
            weldPanel.classList.remove('visible');
            pendingWeld = null;
        };

        document.getElementById('btn-weld-no').onclick = () => {
            weldPanel.classList.remove('visible');
            pendingWeld = null;
        };

        // --- 7. RAYCASTING ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.addEventListener('pointerdown', (e) => {
            if(e.target.closest('button') || e.target.closest('#weld-panel')) return;

            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // Filtrar objetos seleccionables seg√∫n modo
            let objectsToCheck = [];
            if(currentMode === 'vertex') objectsToCheck = vertexHandles;
            if(currentMode === 'edge') objectsToCheck = edgeHandles;
            if(currentMode === 'face') objectsToCheck = faceHandles;

            const intersects = raycaster.intersectObjects(objectsToCheck);
            
            if(intersects.length > 0) {
                transform.attach(intersects[0].object);
            } else if(!transform.dragging) {
                transform.detach();
            }
        });

        // Loop
        function animate() {
            requestAnimationFrame(animate);
            orbit.update();
            renderer.render(scene, camera);
        }
        animate();
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
