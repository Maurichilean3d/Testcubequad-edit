<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Blender Touch - Robust</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1e1e1e; font-family: sans-serif; touch-action: none; }
        
        #toolbar {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 12px; background: rgba(30,30,30,0.9); padding: 12px 20px;
            border-radius: 16px; border: 1px solid #444; backdrop-filter: blur(10px);
            box-shadow: 0 10px 40px rgba(0,0,0,0.6); z-index: 100;
        }

        #top-modes {
            position: absolute; top: 15px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 8px; background: rgba(40,40,40,0.9); padding: 6px;
            border-radius: 12px; border: 1px solid #555;
        }

        .btn {
            width: 44px; height: 44px; border: none; border-radius: 8px; background: #333;
            color: #ccc; cursor: pointer; display: flex; align-items: center; justify-content: center;
            transition: 0.2s; position: relative;
        }
        .btn:active { transform: scale(0.92); }
        .btn.active { background: #3498db; color: white; box-shadow: 0 0 15px rgba(52, 152, 219, 0.3); }
        .btn svg { width: 22px; height: 22px; fill: currentColor; }

        /* Colores */
        .btn[data-mode="vertex"].active { background: #e74c3c; }
        .btn[data-mode="edge"].active { background: #f1c40f; color: #222; }
        
        .action-btn { 
            width: auto; padding: 0 15px; font-weight: bold; font-size: 11px; 
            text-transform: uppercase; flex-direction: column; gap: 3px; height: 50px;
        }
        .btn-extrude { color: #f1c40f; }
        .btn-subdiv { color: #2ecc71; }
        .btn-reset { color: #e74c3c; }

        #stats {
            position: absolute; top: 70px; width: 100%; text-align: center;
            color: #666; font-size: 10px; pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="stats">Topología Quad Safe • <span id="poly-display">6</span> Caras</div>

    <div id="top-modes">
        <button class="btn active" data-mode="vertex"><svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="5"/></svg></button>
        <button class="btn" data-mode="edge"><svg viewBox="0 0 24 24"><path d="M4 20L20 4" stroke="currentColor" stroke-width="4" stroke-linecap="round"/></svg></button>
        <button class="btn" data-mode="face"><svg viewBox="0 0 24 24"><rect x="5" y="5" width="14" height="14" rx="2"/></svg></button>
    </div>

    <div id="toolbar">
        <button class="btn action-btn btn-extrude" id="btn-extrude">
            <svg viewBox="0 0 24 24"><path d="M4 4h16v16H4z M8 8h8v8H8z"/></svg> Extruir
        </button>
        <button class="btn action-btn btn-subdiv" id="btn-subdivide">
            <svg viewBox="0 0 24 24"><path d="M3 3h18v18H3z M12 3v18 M3 12h18"/></svg> Dividir
        </button>
        <button class="btn action-btn btn-reset" id="btn-reset">
            <svg viewBox="0 0 24 24"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/></svg> Reset
        </button>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://ga.jspm.io/npm:three@0.160.0/build/three.module.js",
            "three/addons/": "https://ga.jspm.io/npm:three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';

        // ==========================================
        // 1. MOTOR QUAD ROBUSTO
        // ==========================================
        class QuadEngine {
            constructor() {
                this.vertices = []; 
                this.quads = [];    
            }

            initCube() {
                this.vertices = []; this.quads = [];
                const s = 1; 
                // 8 Vértices base
                const v = [[-s,-s,s],[s,-s,s],[s,s,s],[-s,s,s],[-s,-s,-s],[s,-s,-s],[s,s,-s],[-s,s,-s]];
                v.forEach(p => this.vertices.push(new THREE.Vector3(...p)));
                // 6 Quads
                this.addQuad(0,1,2,3); this.addQuad(5,4,7,6); this.addQuad(1,5,6,2);
                this.addQuad(4,0,3,7); this.addQuad(3,2,6,7); this.addQuad(4,5,1,0);
            }

            addQuad(a,b,c,d) { this.quads.push([a,b,c,d]); }

            // Generador de Geometría con Chequeo de Errores (Safety Check)
            getRenderData() {
                const positions = [];
                let validCount = 0;
                
                for(let q of this.quads) {
                    // Validar integridad de índices
                    if(q.length !== 4) continue;
                    const v0 = this.vertices[q[0]];
                    const v1 = this.vertices[q[1]];
                    const v2 = this.vertices[q[2]];
                    const v3 = this.vertices[q[3]];

                    // Validar existencia de vértices (evita que desaparezca si un índice falla)
                    if(!v0 || !v1 || !v2 || !v3) {
                        console.warn("Quad corrupto detectado, saltando:", q);
                        continue; 
                    }

                    // Tri 1
                    positions.push(v0.x, v0.y, v0.z, v1.x, v1.y, v1.z, v2.x, v2.y, v2.z);
                    // Tri 2
                    positions.push(v0.x, v0.y, v0.z, v2.x, v2.y, v2.z, v3.x, v3.y, v3.z);
                    validCount++;
                }
                return new Float32Array(positions);
            }

            getWireframeData() {
                const positions = [];
                for(let q of this.quads) {
                    const v = q.map(i => this.vertices[i]);
                    if(v.includes(undefined)) continue; // Skip corruptos
                    for(let i=0; i<4; i++) {
                        positions.push(v[i].x, v[i].y, v[i].z);
                        positions.push(v[(i+1)%4].x, v[(i+1)%4].y, v[(i+1)%4].z);
                    }
                }
                return new Float32Array(positions);
            }

            // --- SUBDIVISIÓN CATMULL-CLARK LITE ---
            subdivide() {
                // Límite de seguridad
                if(this.quads.length > 3000) {
                    alert("Límite de geometría alcanzado para móvil.");
                    return;
                }

                const newQuads = [];
                const newVertices = []; // Reconstruimos vértices para limpiar basura
                const edgeCache = new Map(); // "i1_i2" -> newVertexIndex
                const facePoints = []; // Puntos centrales de cada cara

                // 1. Calcular Puntos de Cara (Face Points)
                for(let i=0; i<this.quads.length; i++) {
                    const q = this.quads[i];
                    const fp = new THREE.Vector3()
                        .add(this.vertices[q[0]]).add(this.vertices[q[1]])
                        .add(this.vertices[q[2]]).add(this.vertices[q[3]])
                        .multiplyScalar(0.25);
                    facePoints.push(fp);
                }

                // Helper para agregar vértices al nuevo array
                const addV = (vec) => {
                    newVertices.push(vec);
                    return newVertices.length - 1;
                };

                // Helper para Edge Points
                const getEdgePoint = (i1, i2, faceIndicesSharingEdge) => {
                    const key = i1 < i2 ? `${i1}_${i2}` : `${i2}_${i1}`;
                    if(edgeCache.has(key)) return edgeCache.get(key);

                    // Promedio simple (Linear) + suavizado con FacePoints (Catmull)
                    // Para simplificar y evitar colapsos, usamos promedio lineal en este paso intermedio
                    // Esto garantiza que la malla no se encoja a cero.
                    const v1 = this.vertices[i1];
                    const v2 = this.vertices[i2];
                    const ep = new THREE.Vector3().addVectors(v1, v2).multiplyScalar(0.5);
                    
                    const idx = addV(ep);
                    edgeCache.set(key, idx);
                    return idx;
                };

                // Mapping Old Vertices -> New Vertices (Direct Mapping)
                // En Catmull-Clark real, los vértices originales se mueven. Aquí los mantenemos (Linear Subdiv)
                // para máxima estabilidad en edición.
                const oldToNewMap = new Map();
                for(let i=0; i<this.vertices.length; i++) {
                    oldToNewMap.set(i, addV(this.vertices[i].clone()));
                }

                // 2. Construir Topología
                for(let i=0; i<this.quads.length; i++) {
                    const q = this.quads[i];
                    const cpIdx = addV(facePoints[i]); // Centro de esta cara

                    // Indices de los puntos medios de los 4 bordes
                    const e0 = getEdgePoint(q[0], q[1]);
                    const e1 = getEdgePoint(q[1], q[2]);
                    const e2 = getEdgePoint(q[2], q[3]);
                    const e3 = getEdgePoint(q[3], q[0]);

                    // Indices de los vertices originales (mapeados al nuevo array)
                    const v0 = oldToNewMap.get(q[0]);
                    const v1 = oldToNewMap.get(q[1]);
                    const v2 = oldToNewMap.get(q[2]);
                    const v3 = oldToNewMap.get(q[3]);

                    // 4 Nuevos Quads
                    newQuads.push([v0, e0, cpIdx, e3]);
                    newQuads.push([e0, v1, e1, cpIdx]);
                    newQuads.push([cpIdx, e1, v2, e2]);
                    newQuads.push([e3, cpIdx, e2, v3]);
                }

                // Reemplazo Atómico
                this.vertices = newVertices;
                this.quads = newQuads;
            }

            extrudeFace(index) {
                if(index < 0 || index >= this.quads.length) return;
                const q = this.quads[index];
                
                // Calcular Normal
                const v = q.map(i => this.vertices[i]);
                const n = new THREE.Vector3().subVectors(v[1], v[0]).cross(new THREE.Vector3().subVectors(v[3], v[0])).normalize();
                
                // Crear tapa nueva
                const topIndices = [];
                const dist = 0.5;
                for(let i=0; i<4; i++) {
                    const newPos = v[i].clone().add(n.clone().multiplyScalar(dist));
                    this.vertices.push(newPos);
                    topIndices.push(this.vertices.length-1);
                }

                // Crear lados (puentes)
                for(let i=0; i<4; i++) {
                    const next = (i+1)%4;
                    // Quad lateral: base1, base2, top2, top1
                    this.addQuad(q[i], q[next], topIndices[next], topIndices[i]);
                }

                // Actualizar la cara existente para ser la tapa
                this.quads[index] = topIndices;
            }
        }

        // ==========================================
        // 2. SETUP VISUAL
        // ==========================================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);
        scene.add(new THREE.GridHelper(30, 30, 0x444444, 0x333333));

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(6, 6, 6);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const light = new THREE.DirectionalLight(0xffffff, 1.5);
        light.position.set(5, 10, 7);
        scene.add(light, new THREE.AmbientLight(0xffffff, 0.5));

        // --- MESH ---
        const engine = new QuadEngine();
        engine.initCube();

        // Mesh con Doble Cara para evitar "desapariciones" si la normal se invierte
        const mainMat = new THREE.MeshStandardMaterial({ 
            color: 0x95a5a6, roughness: 0.5, metalness: 0.1, 
            polygonOffset: true, polygonOffsetFactor: 1,
            side: THREE.DoubleSide // CLAVE: Renderiza ambos lados
        });
        const mainMesh = new THREE.Mesh(new THREE.BufferGeometry(), mainMat);
        // Evitar frustum culling incorrecto al deformar
        mainMesh.frustumCulled = false; 
        scene.add(mainMesh);

        const wireMat = new THREE.LineBasicMaterial({ color: 0x111111, opacity: 0.3, transparent: true });
        const wireMesh = new THREE.LineSegments(new THREE.BufferGeometry(), wireMat);
        wireMesh.frustumCulled = false;
        scene.add(wireMesh);

        // --- HANDLES ---
        const helperGroup = new THREE.Group();
        scene.add(helperGroup);

        // Actualización Gráfica
        function updateScene() {
            // Eliminar geometría vieja
            if(mainMesh.geometry) mainMesh.geometry.dispose();
            if(wireMesh.geometry) wireMesh.geometry.dispose();

            // Cargar nueva
            const renderData = engine.getRenderData();
            const wireData = engine.getWireframeData();

            const newMainGeo = new THREE.BufferGeometry();
            newMainGeo.setAttribute('position', new THREE.BufferAttribute(renderData, 3));
            newMainGeo.computeVertexNormals();
            mainMesh.geometry = newMainGeo;

            const newWireGeo = new THREE.BufferGeometry();
            newWireGeo.setAttribute('position', new THREE.BufferAttribute(wireData, 3));
            wireMesh.geometry = newWireGeo;

            document.getElementById('poly-display').innerText = engine.quads.length;
        }

        // --- GESTIÓN DE MODOS ---
        let currentMode = 'vertex';
        let selection = null;

        function rebuildHandles() {
            helperGroup.clear();
            selection = null;
            transform.detach();

            // Optimización: Si hay muchas caras, solo dibujar handles relevantes
            if(engine.vertices.length > 2000 && currentMode !== 'face') return;

            if(currentMode === 'vertex') {
                const geo = new THREE.SphereGeometry(0.12);
                const mat = new THREE.MeshBasicMaterial({ color: 0xe74c3c });
                engine.vertices.forEach((v, i) => {
                    const h = new THREE.Mesh(geo, mat);
                    h.position.copy(v);
                    h.userData = { type: 'vertex', index: i };
                    helperGroup.add(h);
                });
            }
            else if(currentMode === 'edge') {
                // Generar bordes visuales
                const geo = new THREE.BoxGeometry(0.06, 0.06, 1);
                const mat = new THREE.MeshBasicMaterial({ color: 0xf1c40f });
                const visited = new Set();

                engine.quads.forEach(q => {
                    for(let i=0; i<4; i++) {
                        const idx1 = q[i];
                        const idx2 = q[(i+1)%4];
                        const key = idx1 < idx2 ? `${idx1}_${idx2}` : `${idx2}_${idx1}`;
                        
                        if(!visited.has(key)) {
                            visited.add(key);
                            const v1 = engine.vertices[idx1];
                            const v2 = engine.vertices[idx2];
                            const dist = v1.distanceTo(v2);
                            
                            const h = new THREE.Mesh(geo, mat);
                            h.position.copy(v1).add(v2).multiplyScalar(0.5);
                            h.lookAt(v2);
                            h.scale.z = dist * 0.7; // Gap visual
                            h.userData = { type: 'edge', v1: idx1, v2: idx2 };
                            helperGroup.add(h);
                        }
                    }
                });
            }
            else if(currentMode === 'face') {
                const geo = new THREE.PlaneGeometry(0.3, 0.3);
                const mat = new THREE.MeshBasicMaterial({ color: 0x3498db, side: THREE.DoubleSide, transparent:true, opacity:0.7 });
                
                engine.quads.forEach((q, i) => {
                    const center = new THREE.Vector3();
                    q.forEach(vi => center.add(engine.vertices[vi]));
                    center.multiplyScalar(0.25);
                    
                    // Normal
                    const v0 = engine.vertices[q[0]];
                    const v1 = engine.vertices[q[1]];
                    const v3 = engine.vertices[q[3]];
                    const n = new THREE.Vector3().subVectors(v1, v0).cross(new THREE.Vector3().subVectors(v3, v0)).normalize();

                    const h = new THREE.Mesh(geo, mat);
                    h.position.copy(center);
                    h.lookAt(center.clone().add(n));
                    h.userData = { type: 'face', index: i };
                    helperGroup.add(h);
                });
            }
        }

        // ==========================================
        // 3. CONTROLES
        // ==========================================
        const orbit = new OrbitControls(camera, renderer.domElement);
        orbit.enableDamping = true;
        const transform = new TransformControls(camera, renderer.domElement);
        transform.setSpace('local');
        transform.setSize(1.2);
        transform.addEventListener('dragging-changed', e => orbit.enabled = !e.value);
        scene.add(transform);

        // SYNC GIZMO -> ENGINE
        transform.addEventListener('objectChange', () => {
            const h = transform.object;
            const type = h.userData.type;

            if(type === 'vertex') {
                engine.vertices[h.userData.index].copy(h.position);
            } 
            else if(type === 'edge') {
                const v1 = engine.vertices[h.userData.v1];
                const v2 = engine.vertices[h.userData.v2];
                const dist = v1.distanceTo(v2);
                const dir = new THREE.Vector3().subVectors(v2, v1).normalize();
                v1.copy(h.position).addScaledVector(dir, -dist/2);
                v2.copy(h.position).addScaledVector(dir, dist/2);
            }
            updateScene();
        });

        transform.addEventListener('mouseUp', () => {
            if(currentMode !== 'vertex') rebuildHandles();
        });

        // UI Logic
        function setMode(m) {
            currentMode = m;
            document.querySelectorAll('#top-modes .btn').forEach(b => b.classList.remove('active'));
            document.querySelector(`.btn[data-mode="${m}"]`).classList.add('active');
            
            // Habilitar/Deshabilitar Extruir
            document.getElementById('btn-extrude').style.opacity = (m === 'face' ? 1 : 0.3);
            
            rebuildHandles();
        }

        document.querySelectorAll('.btn[data-mode]').forEach(b => b.onclick = () => setMode(b.dataset.mode));

        document.getElementById('btn-extrude').onclick = () => {
            if(currentMode === 'face' && selection) {
                engine.extrudeFace(selection.userData.index);
                updateScene();
                rebuildHandles();
            } else {
                alert("Selecciona una CARA para extruir");
            }
        };

        document.getElementById('btn-subdivide').onclick = () => {
            transform.detach();
            engine.subdivide();
            updateScene();
            rebuildHandles();
        };

        document.getElementById('btn-reset').onclick = () => {
            transform.detach();
            engine.initCube();
            updateScene();
            rebuildHandles();
        };

        // INPUT
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.addEventListener('pointerdown', e => {
            if(e.target.closest('button')) return;

            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObjects(helperGroup.children);

            if(hits.length > 0) {
                selection = hits[0].object;
                transform.attach(selection);
                
                // Color Feedback
                helperGroup.children.forEach(c => {
                    if(c.userData.type === 'vertex') c.material.color.setHex(0xe74c3c);
                    if(c.userData.type === 'edge') c.material.color.setHex(0xf1c40f);
                    if(c.userData.type === 'face') c.material.color.setHex(0x3498db);
                });
                selection.material.color.setHex(0xffffff);
            } else if (!transform.dragging) {
                transform.detach();
                selection = null;
            }
        });

        // INIT
        updateScene();
        rebuildHandles();

        function animate() {
            requestAnimationFrame(animate);
            orbit.update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
