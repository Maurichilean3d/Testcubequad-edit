<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Editor - ESM Version</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: sans-serif; touch-action: none; }
        
        /* UI SUPERIOR */
        #top-bar {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 10px; background: rgba(40, 40, 40, 0.9);
            padding: 10px 15px; border-radius: 12px; border: 1px solid #555;
            backdrop-filter: blur(4px); z-index: 10;
        }

        .mode-btn {
            width: 40px; height: 40px; border: none; border-radius: 8px;
            background: #333; color: #888; cursor: pointer; display: flex; align-items: center; justify-content: center;
            transition: 0.2s;
        }
        .mode-btn:hover { background: #444; color: white; }
        .mode-btn.active { color: white; transform: scale(1.1); }
        
        /* Colores de estado */
        .mode-btn.active[data-mode="vertex"] { background: #e74c3c; box-shadow: 0 0 10px rgba(231, 76, 60, 0.5); }
        .mode-btn.active[data-mode="edge"] { background: #f1c40f; box-shadow: 0 0 10px rgba(241, 196, 15, 0.5); color: #222; }
        .mode-btn.active[data-mode="face"] { background: #3498db; box-shadow: 0 0 10px rgba(52, 152, 219, 0.5); }

        .icon { width: 20px; height: 20px; fill: currentColor; }

        /* PANEL INFERIOR (SOLDAR) */
        #weld-panel {
            position: absolute; bottom: -150px; left: 0; width: 100%;
            background: #2d3436; color: white; padding: 20px 0;
            border-top: 3px solid #00b894; transition: bottom 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex; flex-direction: column; align-items: center;
            box-shadow: 0 -10px 40px rgba(0,0,0,0.5); z-index: 20;
        }
        #weld-panel.visible { bottom: 0; }

        .weld-btns { display: flex; gap: 15px; margin-top: 15px; }
        .btn-action { padding: 10px 25px; border: none; border-radius: 6px; font-weight: bold; cursor: pointer; }
        .btn-yes { background: #00b894; color: white; }
        .btn-no { background: #d63031; color: white; }

        /* PANTALLA DE CARGA / ERROR */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #111; color: #fff; display: flex; align-items: center; justify-content: center;
            z-index: 9999; flex-direction: column;
        }
    </style>
</head>
<body>

    <div id="loader">Cargando Three.js...<br><small>(Si esto no desaparece, revisa tu conexiÃ³n)</small></div>

    <div id="top-bar">
        <button class="mode-btn active" data-mode="vertex" title="VÃ©rtice">
            <svg class="icon" viewBox="0 0 24 24"><circle cx="12" cy="12" r="5"/></svg>
        </button>
        <button class="mode-btn" data-mode="edge" title="Borde">
            <svg class="icon" viewBox="0 0 24 24"><path d="M4 20L20 4" stroke="currentColor" stroke-width="4" stroke-linecap="round"/></svg>
        </button>
        <button class="mode-btn" data-mode="face" title="Cara">
            <svg class="icon" viewBox="0 0 24 24"><rect x="5" y="5" width="14" height="14" rx="2"/></svg>
        </button>
    </div>

    <div id="weld-panel">
        <div>ðŸ”— FusiÃ³n Detectada</div>
        <div class="weld-btns">
            <button class="btn-action btn-yes" id="btn-yes">SOLDAR</button>
            <button class="btn-action btn-no" id="btn-no">CANCELAR</button>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://ga.jspm.io/npm:three@0.160.0/build/three.module.js",
            "three/addons/": "https://ga.jspm.io/npm:three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        // Importamos Three y addons
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';

        // Ocultar pantalla de carga si todo saliÃ³ bien
        document.getElementById('loader').style.display = 'none';

        // --- 1. ESCENA ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);
        scene.add(new THREE.GridHelper(20, 20, 0x333333, 0x222222));

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(4, 3, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const light = new THREE.DirectionalLight(0xffffff, 1.5);
        light.position.set(5, 10, 7);
        scene.add(light, new THREE.AmbientLight(0xffffff, 0.5));

        // --- 2. OBJETO ---
        let geometry = new THREE.BoxGeometry(2, 2, 2).toNonIndexed();
        const material = new THREE.MeshStandardMaterial({ 
            color: 0x555555, roughness: 0.5, metalness: 0.1,
            polygonOffset: true, polygonOffsetFactor: 1, polygonOffsetUnits: 1
        });
        const cube = new THREE.Mesh(geometry, material);
        scene.add(cube);

        let wireframe = new THREE.LineSegments(
            new THREE.EdgesGeometry(geometry),
            new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 })
        );
        cube.add(wireframe);

        // --- 3. GENERAR PUNTOS DE CONTROL ---
        const helpers = new THREE.Group();
        scene.add(helpers);

        let vHandles = [], eHandles = [], fHandles = [];
        let mapV = []; // ID -> [indices reales]

        function buildHelpers() {
            helpers.clear();
            vHandles = []; eHandles = []; fHandles = [];
            mapV = [];

            const pos = geometry.attributes.position;
            
            // A. VERTICES (Unificar posiciones)
            const corners = {};
            for(let i=0; i<pos.count; i++) {
                const k = `${pos.getX(i).toFixed(3)},${pos.getY(i).toFixed(3)},${pos.getZ(i).toFixed(3)}`;
                if(!corners[k]) corners[k] = [];
                corners[k].push(i);
            }

            let idx = 0;
            const vMat = new THREE.MeshBasicMaterial({ color: 0xe74c3c, depthTest: false });
            const vGeo = new THREE.SphereGeometry(0.12);

            for(const k in corners) {
                const indices = corners[k];
                const i = indices[0];
                const m = new THREE.Mesh(vGeo, vMat.clone());
                m.position.set(pos.getX(i), pos.getY(i), pos.getZ(i));
                m.userData = { type: 'vertex', id: idx };
                m.renderOrder = 10;
                helpers.add(m);
                vHandles.push(m);
                mapV[idx] = indices;
                idx++;
            }

            // B. BORDES (Conectar vertices cercanos)
            const eMat = new THREE.MeshBasicMaterial({ color: 0xf1c40f, depthTest: false });
            for(let i=0; i<vHandles.length; i++) {
                for(let j=i+1; j<vHandles.length; j++) {
                    const p1 = vHandles[i].position;
                    const p2 = vHandles[j].position;
                    const d = p1.distanceTo(p2);
                    if(d > 0.1 && d < 2.1) {
                        const mid = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5);
                        const m = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.06, d), eMat.clone());
                        m.position.copy(mid);
                        m.lookAt(p2);
                        m.userData = { type: 'edge', v1: i, v2: j };
                        helpers.add(m);
                        eHandles.push(m);
                    }
                }
            }

            // C. CARAS (Centros)
            const fMat = new THREE.MeshBasicMaterial({ color: 0x3498db, depthTest: false, transparent: true, opacity: 0.7, side: THREE.DoubleSide });
            const fGeo = new THREE.PlaneGeometry(0.5, 0.5);
            
            // Direcciones iniciales del cubo
            const dirs = [
                new THREE.Vector3(1,0,0), new THREE.Vector3(-1,0,0),
                new THREE.Vector3(0,1,0), new THREE.Vector3(0,-1,0),
                new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,-1)
            ];

            dirs.forEach(dir => {
                const center = dir.clone();
                // Buscar los 4 vÃ©rtices mÃ¡s cercanos
                const sorted = vHandles.map((v, i) => ({ d: v.position.distanceTo(center), id: i }))
                                       .sort((a,b) => a.d - b.d);
                const closest = sorted.slice(0, 4).map(x => x.id);

                const m = new THREE.Mesh(fGeo, fMat.clone());
                m.position.copy(center);
                m.lookAt(center.clone().add(dir));
                m.userData = { type: 'face', vIDs: closest };
                helpers.add(m);
                fHandles.push(m);
            });
        }
        buildHelpers();

        // --- 4. CONTROL ---
        const orbit = new OrbitControls(camera, renderer.domElement);
        orbit.enableDamping = true;
        
        const transform = new TransformControls(camera, renderer.domElement);
        transform.setSpace('local');
        transform.setSize(1.2);
        scene.add(transform);

        let currentMode = 'vertex';
        function setMode(m) {
            currentMode = m;
            transform.detach();
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            document.querySelector(`[data-mode="${m}"]`).classList.add('active');
            
            vHandles.forEach(h => h.visible = (m === 'vertex'));
            eHandles.forEach(h => h.visible = (m === 'edge'));
            fHandles.forEach(h => h.visible = (m === 'face'));
        }
        document.querySelectorAll('.mode-btn').forEach(b => b.onclick = () => setMode(b.dataset.mode));
        setMode('vertex');

        // Logic de arrastre
        transform.addEventListener('dragging-changed', e => {
            orbit.enabled = !e.value;
            if(!e.value && currentMode === 'vertex') checkWeld(transform.object);
        });

        transform.addEventListener('objectChange', () => {
            const h = transform.object;
            if(h.userData.type === 'vertex') updateGeo(h);
            else if(h.userData.type === 'edge') {
                const v1 = vHandles[h.userData.v1];
                const v2 = vHandles[h.userData.v2];
                // Truco: Mover los 2 vertices relativos al handle
                // (Simplificado: reiniciamos posiciones desde el centro del handle)
                const dist = v1.position.distanceTo(v2.position);
                const axis = new THREE.Vector3(0,0,1).applyQuaternion(h.quaternion).normalize();
                
                v1.position.copy(h.position).addScaledVector(axis, -dist/2);
                v2.position.copy(h.position).addScaledVector(axis, dist/2);
                
                updateGeo(v1); updateGeo(v2);
            }
            else if(h.userData.type === 'face') {
                const ids = h.userData.vIDs;
                // Calcular centro actual
                const center = new THREE.Vector3();
                ids.forEach(i => center.add(vHandles[i].position));
                center.divideScalar(ids.length);
                
                const delta = new THREE.Vector3().subVectors(h.position, center);
                ids.forEach(i => {
                    vHandles[i].position.add(delta);
                    updateGeo(vHandles[i]);
                });
            }
            updateHelpers(h);
        });

        function updateGeo(vHandle) {
            const indices = mapV[vHandle.userData.id];
            indices.forEach(idx => {
                geometry.attributes.position.setXYZ(idx, vHandle.position.x, vHandle.position.y, vHandle.position.z);
            });
            geometry.attributes.position.needsUpdate = true;
            updateWireframe();
        }

        function updateWireframe() {
            cube.remove(wireframe);
            wireframe.geometry.dispose();
            wireframe = new THREE.LineSegments(new THREE.EdgesGeometry(geometry), new THREE.LineBasicMaterial({color:0}));
            cube.add(wireframe);
        }

        function updateHelpers(exclude) {
            eHandles.forEach(e => {
                if(e === exclude) return;
                const p1 = vHandles[e.userData.v1].position;
                const p2 = vHandles[e.userData.v2].position;
                e.position.copy(p1).add(p2).multiplyScalar(0.5);
                e.lookAt(p2);
                e.scale.z = p1.distanceTo(p2); // Ajustar largo visual
            });
            fHandles.forEach(f => {
                if(f === exclude) return;
                const ids = f.userData.vIDs;
                const c = new THREE.Vector3();
                ids.forEach(i => c.add(vHandles[i].position));
                c.divideScalar(ids.length);
                f.position.copy(c);
            });
        }

        // --- 5. SOLDAR ---
        const panel = document.getElementById('weld-panel');
        let pending = null;

        function checkWeld(h) {
            let target = null;
            for(let other of vHandles) {
                if(other !== h && h.position.distanceTo(other.position) < 0.4) {
                    target = other; break;
                }
            }
            if(target) {
                pending = { active: h, target: target };
                panel.classList.add('visible');
            } else {
                panel.classList.remove('visible');
            }
        }

        document.getElementById('btn-yes').onclick = () => {
            if(pending) {
                pending.active.position.copy(pending.target.position);
                updateGeo(pending.active);
                updateHelpers();
            }
            panel.classList.remove('visible');
            pending = null;
        }
        document.getElementById('btn-no').onclick = () => {
            panel.classList.remove('visible');
            pending = null;
        }

        // --- INPUT ---
        const ray = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.addEventListener('pointerdown', e => {
            if(e.target.closest('button') || e.target.closest('#weld-panel')) return;
            const r = renderer.domElement.getBoundingClientRect();
            mouse.x = ((e.clientX - r.left)/r.width)*2-1;
            mouse.y = -((e.clientY - r.top)/r.height)*2+1;
            ray.setFromCamera(mouse, camera);

            let objs = [];
            if(currentMode==='vertex') objs = vHandles;
            else if(currentMode==='edge') objs = eHandles;
            else if(currentMode==='face') objs = fHandles;

            const hits = ray.intersectObjects(objs);
            if(hits.length) transform.attach(hits[0].object);
            else if(!transform.dragging) transform.detach();
        });

        function animate() {
            requestAnimationFrame(animate);
            orbit.update();
            renderer.render(scene, camera);
        }
        animate();

        window.onresize = () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };
    </script>
</body>
</html>
