<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Web 3D Modeler - V茅rtices, Bordes y Caras</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #151515; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        
        /* --- BARRA SUPERIOR (MODOS) --- */
        #top-bar {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 10px; background: rgba(30, 30, 30, 0.95);
            padding: 8px 12px; border-radius: 12px; border: 1px solid #444;
            backdrop-filter: blur(5px); pointer-events: auto; z-index: 10;
        }

        .mode-btn {
            width: 45px; height: 45px; border: none; border-radius: 8px;
            background: #333; color: #aaa; cursor: pointer; 
            display: flex; align-items: center; justify-content: center;
            transition: all 0.2s;
        }
        
        .mode-btn:hover { background: #444; color: white; }
        .mode-btn svg { width: 24px; height: 24px; fill: currentColor; }
        
        .mode-btn.active[data-mode="vertex"] { background: #e74c3c; color: white; box-shadow: 0 0 10px rgba(231, 76, 60, 0.4); }
        .mode-btn.active[data-mode="edge"] { background: #f1c40f; color: black; box-shadow: 0 0 10px rgba(241, 196, 15, 0.4); }
        .mode-btn.active[data-mode="face"] { background: #3498db; color: white; box-shadow: 0 0 10px rgba(52, 152, 219, 0.4); }

        /* --- UI INFERIOR (SOLDAR) --- */
        #weld-panel {
            position: absolute; bottom: -200px; left: 0; width: 100%;
            background: #2c3e50; color: white; border-top: 4px solid #2ecc71;
            padding: 25px 0; transition: bottom 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            box-shadow: 0 -5px 30px rgba(0,0,0,0.6); z-index: 100;
        }
        
        #weld-panel.visible { bottom: 0; }

        .weld-controls { display: flex; gap: 20px; margin-top: 15px; }
        
        .action-btn {
            padding: 12px 30px; border: none; border-radius: 8px; 
            font-weight: bold; cursor: pointer; font-size: 1rem;
        }
        .btn-yes { background: #2ecc71; color: white; }
        .btn-no { background: #e74c3c; color: white; }

        #hint {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            color: #666; font-size: 13px; pointer-events: none; transition: opacity 0.3s;
        }
    </style>
</head>
<body>

    <div id="top-bar">
        <button class="mode-btn active" data-mode="vertex" title="V茅rtices">
            <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="5"/></svg>
        </button>
        <button class="mode-btn" data-mode="edge" title="Bordes">
            <svg viewBox="0 0 24 24"><path d="M4 20L20 4" stroke="currentColor" stroke-width="4" stroke-linecap="round"/></svg>
        </button>
        <button class="mode-btn" data-mode="face" title="Caras">
            <svg viewBox="0 0 24 24"><rect x="5" y="5" width="14" height="14" rx="2"/></svg>
        </button>
    </div>

    <div id="hint">Selecciona un elemento para editar</div>

    <div id="weld-panel">
        <div style="font-size: 1.2rem; font-weight: 600;"> Fusi贸n Detectada</div>
        <div style="color: #bdc3c7;">驴Deseas soldar estos puntos?</div>
        <div class="weld-controls">
            <button class="action-btn btn-yes" id="btn-weld-yes">S, UNIR</button>
            <button class="action-btn btn-no" id="btn-weld-no">CANCELAR</button>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';

        // --- 1. SETUP ESCENA ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x151515);
        scene.add(new THREE.GridHelper(30, 30, 0x333333, 0x222222));

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(5, 4, 6);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const light = new THREE.DirectionalLight(0xffffff, 1.5);
        light.position.set(5, 10, 7);
        scene.add(light, new THREE.AmbientLight(0xffffff, 0.5));

        // --- 2. GEOMETRA ---
        // Usamos toNonIndexed para tener control total de los v茅rtices (Exploded logic)
        let geometry = new THREE.BoxGeometry(2, 2, 2).toNonIndexed();
        const material = new THREE.MeshStandardMaterial({
            color: 0x555555, roughness: 0.5, metalness: 0.1,
            polygonOffset: true, polygonOffsetFactor: 1, polygonOffsetUnits: 1
        });
        const cube = new THREE.Mesh(geometry, material);
        scene.add(cube);

        // Wireframe (L铆neas negras)
        let wireframe = new THREE.LineSegments(
            new THREE.EdgesGeometry(geometry),
            new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 })
        );
        cube.add(wireframe);

        // --- 3. GENERADOR DE HANDLES ---
        const helpersGroup = new THREE.Group();
        scene.add(helpersGroup);

        let vertexHandles = [], edgeHandles = [], faceHandles = [];
        let mapVertex = []; // Mapa: ID Handle -> [Indices reales]

        function generateHelpers() {
            helpersGroup.clear();
            vertexHandles = []; edgeHandles = []; faceHandles = [];
            mapVertex = [];

            const pos = geometry.attributes.position;
            const size = 0.15;

            // -- A. VERTICES (Agrupados por posici贸n) --
            const corners = {};
            for(let i=0; i<pos.count; i++){
                // Clave 煤nica basada en posici贸n XYZ
                const key = `${pos.getX(i).toFixed(3)},${pos.getY(i).toFixed(3)},${pos.getZ(i).toFixed(3)}`;
                if(!corners[key]) corners[key] = [];
                corners[key].push(i);
            }

            let cIdx = 0;
            const vGeo = new THREE.SphereGeometry(size);
            const vMat = new THREE.MeshBasicMaterial({ color: 0xe74c3c, depthTest: false }); // Rojo

            Object.values(corners).forEach(indices => {
                const i = indices[0];
                const mesh = new THREE.Mesh(vGeo, vMat.clone());
                mesh.position.set(pos.getX(i), pos.getY(i), pos.getZ(i));
                mesh.userData = { type: 'vertex', id: cIdx };
                mesh.renderOrder = 999; // Siempre visible encima
                
                helpersGroup.add(mesh);
                vertexHandles.push(mesh);
                mapVertex[cIdx] = indices;
                cIdx++;
            });

            // -- B. BORDES (Conectan 2 vertices cercanos) --
            let eIdx = 0;
            const eMat = new THREE.MeshBasicMaterial({ color: 0xf1c40f, depthTest: false }); // Amarillo
            
            for(let i=0; i<vertexHandles.length; i++) {
                for(let j=i+1; j<vertexHandles.length; j++) {
                    const v1 = vertexHandles[i];
                    const v2 = vertexHandles[j];
                    const dist = v1.position.distanceTo(v2.position);

                    // Si la distancia es aprox 2 (lado del cubo) o menor si se deforma, pero no diagonal (2.8)
                    // Filtro simple para demo: bordes < 2.2 y > 0.1
                    if(dist > 0.1 && dist < 2.2) {
                        const mid = new THREE.Vector3().addVectors(v1.position, v2.position).multiplyScalar(0.5);
                        const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.08, dist), eMat.clone());
                        mesh.position.copy(mid);
                        mesh.lookAt(v2.position);
                        mesh.userData = { type: 'edge', v1: i, v2: j };
                        
                        helpersGroup.add(mesh);
                        edgeHandles.push(mesh);
                    }
                }
            }

            // -- C. CARAS (Centros de 4 vertices) --
            // Generaci贸n simplificada basada en normales del cubo original
            const fGeo = new THREE.PlaneGeometry(0.6, 0.6);
            const fMat = new THREE.MeshBasicMaterial({ color: 0x3498db, depthTest: false, side: THREE.DoubleSide, transparent: true, opacity: 0.8 });
            
            // Direcciones b谩sicas de un cubo
            const dirs = [
                new THREE.Vector3(1,0,0), new THREE.Vector3(-1,0,0),
                new THREE.Vector3(0,1,0), new THREE.Vector3(0,-1,0),
                new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,-1)
            ];

            dirs.forEach((dir, idx) => {
                // Posici贸n te贸rica del centro de la cara
                const center = dir.clone(); 
                
                // Buscar los 4 v茅rtices m谩s cercanos a este centro
                const sorted = vertexHandles.map((v, i) => ({ dist: v.position.distanceTo(center), id: i }))
                                            .sort((a, b) => a.dist - b.dist);
                const closest4 = sorted.slice(0, 4).map(x => x.id);

                const mesh = new THREE.Mesh(fGeo, fMat.clone());
                mesh.position.copy(center);
                mesh.lookAt(center.clone().add(dir));
                mesh.userData = { type: 'face', vertIDs: closest4 };
                
                helpersGroup.add(mesh);
                faceHandles.push(mesh);
            });
        }
        generateHelpers();

        // --- 4. GESTIN DE MODOS ---
        let currentMode = 'vertex'; 

        function setMode(mode) {
            currentMode = mode;
            transform.detach();
            document.getElementById('hint').style.opacity = '1';
            
            // Actualizar botones
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            document.querySelector(`.mode-btn[data-mode="${mode}"]`).classList.add('active');

            // Mostrar/Ocultar Handles
            vertexHandles.forEach(h => h.visible = (mode === 'vertex'));
            edgeHandles.forEach(h => h.visible = (mode === 'edge'));
            faceHandles.forEach(h => h.visible = (mode === 'face'));
        }

        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', () => setMode(btn.dataset.mode));
        });
        setMode('vertex');

        // --- 5. LGICA DE TRANSFORMACIN ---
        const orbit = new OrbitControls(camera, renderer.domElement);
        orbit.enableDamping = true;
        
        const transform = new TransformControls(camera, renderer.domElement);
        transform.setSpace('local');
        transform.setSize(1.2); 
        scene.add(transform);

        transform.addEventListener('dragging-changed', (e) => {
            orbit.enabled = !e.value;
            if(e.value) {
                document.getElementById('hint').style.opacity = '0';
            } else {
                // Al soltar, verificamos soldadura
                if(currentMode === 'vertex') checkWeld(transform.object);
            }
        });

        transform.addEventListener('objectChange', () => {
            const handle = transform.object;
            const type = handle.userData.type;

            if(type === 'vertex') {
                updateGeoFromVertex(handle);
            } else if(type === 'edge') {
                // Mover Borde (Simplificado: mueve los 2 v茅rtices)
                // Calculamos el delta desde la 煤ltima posici贸n conocida no es fiable aqu铆
                // Reconstruimos posiciones desde el centro del handle
                const v1 = vertexHandles[handle.userData.v1];
                const v2 = vertexHandles[handle.userData.v2];
                
                // Distancia actual entre vertices
                const currentDist = v1.position.distanceTo(v2.position);
                const halfDir = new THREE.Vector3().subVectors(v2.position, v1.position).normalize().multiplyScalar(currentDist/2);
                
                // Forzamos que v1 y v2 sigan al handle manteniendo su separaci贸n relativa
                // (Nota: Esto impide rotar el borde con el gizmo, solo trasladar, para rotar se requiere l贸gica de grupo m谩s compleja)
                v1.position.subVectors(handle.position, halfDir);
                v2.position.addVectors(handle.position, halfDir);
                
                updateGeoFromVertex(v1);
                updateGeoFromVertex(v2);
            } else if(type === 'face') {
                // Mover Cara
                // Mueve todos los v茅rtices asociados a la posici贸n del handle
                // (Requiere guardar offsets relativos para ser perfecto, aqu铆 hacemos un "snap" de grupo)
                const vIDs = handle.userData.vertIDs;
                
                // Calcular centroide actual de los vertices
                const centroid = new THREE.Vector3();
                vIDs.forEach(id => centroid.add(vertexHandles[id].position));
                centroid.divideScalar(vIDs.length);
                
                const delta = new THREE.Vector3().subVectors(handle.position, centroid);
                
                vIDs.forEach(id => {
                    vertexHandles[id].position.add(delta);
                    updateGeoFromVertex(vertexHandles[id]);
                });
            }
            
            updateHelperPositions(handle);
        });

        function updateGeoFromVertex(vHandle) {
            const indices = mapVertex[vHandle.userData.id];
            indices.forEach(idx => {
                geometry.attributes.position.setXYZ(idx, vHandle.position.x, vHandle.position.y, vHandle.position.z);
            });
            geometry.attributes.position.needsUpdate = true;
            updateWireframe();
        }

        function updateHelperPositions(exclude) {
            // Recalcular posiciones visuales de bordes y caras
            edgeHandles.forEach(eh => {
                if(eh === exclude) return;
                const p1 = vertexHandles[eh.userData.v1].position;
                const p2 = vertexHandles[eh.userData.v2].position;
                eh.position.copy(p1).add(p2).multiplyScalar(0.5);
                eh.lookAt(p2);
                eh.scale.z = p1.distanceTo(p2);
            });
            
            faceHandles.forEach(fh => {
                if(fh === exclude) return;
                const vIDs = fh.userData.vertIDs;
                const center = new THREE.Vector3();
                vIDs.forEach(id => center.add(vertexHandles[id].position));
                center.divideScalar(vIDs.length);
                fh.position.copy(center);
            });
        }

        function updateWireframe() {
            cube.remove(wireframe);
            wireframe.geometry.dispose();
            wireframe = new THREE.LineSegments(new THREE.EdgesGeometry(geometry), new THREE.LineBasicMaterial({ color: 0x000000 }));
            cube.add(wireframe);
        }

        // --- 6. SISTEMA DE SOLDADO ---
        const weldPanel = document.getElementById('weld-panel');
        let pendingWeld = null;

        function checkWeld(handle) {
            const threshold = 0.4;
            let target = null;

            for(let other of vertexHandles) {
                if(other === handle) continue;
                if(handle.position.distanceTo(other.position) < threshold) {
                    target = other;
                    break;
                }
            }

            if(target) {
                pendingWeld = { active: handle, target: target };
                weldPanel.classList.add('visible');
            } else {
                weldPanel.classList.remove('visible');
            }
        }

        document.getElementById('btn-weld-yes').onclick = () => {
            if(pendingWeld) {
                const { active, target } = pendingWeld;
                active.position.copy(target.position);
                updateGeoFromVertex(active);
                updateHelperPositions();
            }
            weldPanel.classList.remove('visible');
            pendingWeld = null;
        };
        
        document.getElementById('btn-weld-no').onclick = () => {
            weldPanel.classList.remove('visible');
            pendingWeld = null;
        };

        // --- 7. INPUT (RAYCASTER) ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.addEventListener('pointerdown', (e) => {
            if(e.target.closest('button') || e.target.closest('#weld-panel')) return;

            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            let candidates = [];
            if(currentMode === 'vertex') candidates = vertexHandles;
            if(currentMode === 'edge') candidates = edgeHandles;
            if(currentMode === 'face') candidates = faceHandles;

            const intersects = raycaster.intersectObjects(candidates);
            if(intersects.length > 0) {
                transform.attach(intersects[0].object);
            } else if(!transform.dragging) {
                transform.detach();
            }
        });

        function animate() {
            requestAnimationFrame(animate);
            orbit.update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
