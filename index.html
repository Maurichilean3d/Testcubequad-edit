<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Blender Lite - Ultimate</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #222; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        
        /* --- UI PRINCIPAL --- */
        .toolbar {
            position: absolute; display: flex; gap: 8px; background: rgba(30,30,30,0.95);
            padding: 8px; border-radius: 12px; border: 1px solid #444; backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0,0,0,0.5); pointer-events: auto;
        }

        #top-bar { top: 15px; left: 50%; transform: translateX(-50%); z-index: 10; }
        #bottom-bar { bottom: 30px; left: 50%; transform: translateX(-50%); width: 90%; max-width: 400px; justify-content: center; }

        .btn {
            width: 45px; height: 45px; border: none; border-radius: 8px; background: #3a3a3a;
            color: #aaa; cursor: pointer; display: flex; align-items: center; justify-content: center;
            transition: 0.2s; position: relative;
        }
        .btn svg { width: 24px; height: 24px; fill: currentColor; }
        .btn:active { transform: scale(0.95); }
        .btn.active { background: #3498db; color: white; box-shadow: 0 0 10px rgba(52, 152, 219, 0.4); }

        /* Estilos específicos por modo */
        .btn[data-mode="vertex"].active { background: #e74c3c; }
        .btn[data-mode="edge"].active { background: #f1c40f; color: #111; }
        
        /* Botones de Acción (Texto) */
        .action-btn { flex: 1; height: 50px; font-weight: bold; font-size: 11px; text-transform: uppercase; flex-direction: column; gap: 4px; }
        .btn-extrude { color: #f1c40f; }
        .btn-subdiv { color: #2ecc71; }
        .btn-delete { color: #e74c3c; }

        #info-overlay {
            position: absolute; top: 70px; width: 100%; text-align: center;
            color: #666; font-size: 11px; pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="info-overlay">Motor Quad v2.0 • Selecciona y Mueve</div>

    <div id="top-bar" class="toolbar">
        <button class="btn active" data-mode="vertex" title="Vértices">
            <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="5"/></svg>
        </button>
        <button class="btn" data-mode="edge" title="Bordes">
            <svg viewBox="0 0 24 24"><path d="M4 20L20 4" stroke="currentColor" stroke-width="4" stroke-linecap="round"/></svg>
        </button>
        <button class="btn" data-mode="face" title="Caras">
            <svg viewBox="0 0 24 24"><rect x="5" y="5" width="14" height="14" rx="2"/></svg>
        </button>
    </div>

    <div id="bottom-bar" class="toolbar">
        <button class="btn action-btn btn-extrude" id="btn-extrude">
            <svg viewBox="0 0 24 24" style="width:20px"><path d="M4 4h16v16H4z M8 8h8v8H8z"/></svg> Extruir
        </button>
        <button class="btn action-btn btn-subdiv" id="btn-subdivide">
            <svg viewBox="0 0 24 24" style="width:20px"><path d="M3 3h18v18H3z M12 3v18 M3 12h18"/></svg> Dividir
        </button>
        <button class="btn action-btn btn-delete" id="btn-delete">
            <svg viewBox="0 0 24 24" style="width:20px"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg> Borrar
        </button>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://ga.jspm.io/npm:three@0.160.0/build/three.module.js",
            "three/addons/": "https://ga.jspm.io/npm:three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';

        // ==========================================
        // 1. MOTOR DE TOPOLOGÍA (QUAD ENGINE)
        // ==========================================
        class QuadEngine {
            constructor() {
                this.vertices = []; // Array de Vector3
                this.quads = [];    // Array de [i1, i2, i3, i4]
            }

            // Inicializar Cubo Base
            initCube() {
                this.vertices = []; this.quads = [];
                const s = 1; 
                // 8 vertices
                const v = [[-s,-s,s],[s,-s,s],[s,s,s],[-s,s,s],[-s,-s,-s],[s,-s,-s],[s,s,-s],[-s,s,-s]];
                v.forEach(p => this.vertices.push(new THREE.Vector3(...p)));
                
                // 6 Quads (Orden CCW)
                this.addQuad(0,1,2,3); // Front
                this.addQuad(5,4,7,6); // Back
                this.addQuad(1,5,6,2); // Right
                this.addQuad(4,0,3,7); // Left
                this.addQuad(3,2,6,7); // Top
                this.addQuad(4,5,1,0); // Bottom
            }

            addQuad(a,b,c,d) { this.quads.push([a,b,c,d]); }

            // Generar Mesh Visual (Three.js)
            getRenderData() {
                const positions = [];
                // Convertir Quads a Triángulos para GPU
                for(let q of this.quads) {
                    const v = q.map(i => this.vertices[i]);
                    // Tri 1
                    positions.push(v[0].x, v[0].y, v[0].z, v[1].x, v[1].y, v[1].z, v[2].x, v[2].y, v[2].z);
                    // Tri 2
                    positions.push(v[0].x, v[0].y, v[0].z, v[2].x, v[2].y, v[2].z, v[3].x, v[3].y, v[3].z);
                }
                return new Float32Array(positions);
            }

            // Wireframe Limpio (Solo bordes de quads)
            getWireframeData() {
                const positions = [];
                for(let q of this.quads) {
                    const v = q.map(i => this.vertices[i]);
                    for(let i=0; i<4; i++) {
                        positions.push(v[i].x, v[i].y, v[i].z);
                        positions.push(v[(i+1)%4].x, v[(i+1)%4].y, v[(i+1)%4].z);
                    }
                }
                return new Float32Array(positions);
            }

            // --- OPERACIONES ---
            
            subdivide() {
                const newQuads = [];
                const edgeCache = new Map(); // "min_max" -> index

                const getMid = (i1, i2) => {
                    const key = i1<i2 ? `${i1}_${i2}` : `${i2}_${i1}`;
                    if(edgeCache.has(key)) return edgeCache.get(key);
                    const mid = new THREE.Vector3().addVectors(this.vertices[i1], this.vertices[i2]).multiplyScalar(0.5);
                    this.vertices.push(mid);
                    const idx = this.vertices.length-1;
                    edgeCache.set(key, idx);
                    return idx;
                };

                for(let q of this.quads) {
                    // Centro
                    const cPos = new THREE.Vector3().add(this.vertices[q[0]]).add(this.vertices[q[1]]).add(this.vertices[q[2]]).add(this.vertices[q[3]]).multiplyScalar(0.25);
                    this.vertices.push(cPos);
                    const cIdx = this.vertices.length-1;
                    
                    // Mids
                    const m01 = getMid(q[0], q[1]);
                    const m12 = getMid(q[1], q[2]);
                    const m23 = getMid(q[2], q[3]);
                    const m30 = getMid(q[3], q[0]);

                    // 4 Hijos
                    newQuads.push([q[0], m01, cIdx, m30]);
                    newQuads.push([m01, q[1], m12, cIdx]);
                    newQuads.push([cIdx, m12, q[2], m23]);
                    newQuads.push([m30, cIdx, m23, q[3]]);
                }
                this.quads = newQuads;
            }

            extrudeFace(quadIndex) {
                if(quadIndex < 0 || quadIndex >= this.quads.length) return;
                const q = this.quads[quadIndex];
                
                // Calcular normal
                const v = q.map(i => this.vertices[i]);
                const n = new THREE.Vector3().subVectors(v[1], v[0]).cross(new THREE.Vector3().subVectors(v[3], v[0])).normalize();
                
                // Crear 4 nuevos vértices extruidos
                const baseIndices = [...q];
                const topIndices = [];
                const dist = 0.5;

                for(let i=0; i<4; i++) {
                    const newPos = v[i].clone().add(n.clone().multiplyScalar(dist));
                    this.vertices.push(newPos);
                    topIndices.push(this.vertices.length-1);
                }

                // Crear 4 caras laterales
                for(let i=0; i<4; i++) {
                    const next = (i+1)%4;
                    this.addQuad(baseIndices[i], baseIndices[next], topIndices[next], topIndices[i]);
                }

                // Actualizar la cara original para que sea la "tapa" (Top)
                this.quads[quadIndex] = topIndices;
                return quadIndex; // Retornar indice para mantener selección
            }

            deleteFace(index) {
                if(index > -1) this.quads.splice(index, 1);
            }
        }

        // ==========================================
        // 2. SETUP ESCENA
        // ==========================================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);
        scene.add(new THREE.GridHelper(20, 20, 0x444444, 0x333333));

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(5, 5, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const light = new THREE.DirectionalLight(0xffffff, 1.2);
        light.position.set(5, 10, 7);
        scene.add(light, new THREE.AmbientLight(0xffffff, 0.5));

        // --- OBJETOS ---
        const engine = new QuadEngine();
        engine.initCube();

        // Malla Visual (Triángulos renderizados)
        const mainGeo = new THREE.BufferGeometry();
        const mainMat = new THREE.MeshStandardMaterial({ 
            color: 0x7f8c8d, roughness: 0.5, metalness: 0.1, 
            polygonOffset: true, polygonOffsetFactor: 1 
        });
        const mesh = new THREE.Mesh(mainGeo, mainMat);
        scene.add(mesh);

        // Wireframe (Líneas Quad reales)
        const wireGeo = new THREE.BufferGeometry();
        const wireMat = new THREE.LineBasicMaterial({ color: 0x111111, opacity: 0.4, transparent: true });
        const wireMesh = new THREE.LineSegments(wireGeo, wireMat);
        scene.add(wireMesh);

        // --- HANDLES (Controles Visuales) ---
        const helperGroup = new THREE.Group();
        scene.add(helperGroup);

        // ==========================================
        // 3. ACTUALIZACIÓN VISUAL
        // ==========================================
        function updateGeometry() {
            // Actualizar Render
            const renderData = engine.getRenderData();
            mainGeo.setAttribute('position', new THREE.BufferAttribute(renderData, 3));
            mainGeo.computeVertexNormals();
            mainGeo.attributes.position.needsUpdate = true;

            // Actualizar Wireframe
            const wireData = engine.getWireframeData();
            wireGeo.setAttribute('position', new THREE.BufferAttribute(wireData, 3));
            wireGeo.attributes.position.needsUpdate = true;
        }

        let currentMode = 'vertex';
        let selection = null; // { object: Handle, id: ID_Handle }

        function rebuildHandles() {
            helperGroup.clear();
            selection = null;
            transform.detach();

            if(currentMode === 'vertex') {
                const geo = new THREE.SphereGeometry(0.12);
                const mat = new THREE.MeshBasicMaterial({ color: 0xe74c3c }); // Rojo
                
                engine.vertices.forEach((v, i) => {
                    const h = new THREE.Mesh(geo, mat);
                    h.position.copy(v);
                    h.userData = { type: 'vertex', index: i };
                    helperGroup.add(h);
                });
            } 
            else if(currentMode === 'edge') {
                const geo = new THREE.BoxGeometry(0.06, 0.06, 1);
                const mat = new THREE.MeshBasicMaterial({ color: 0xf1c40f }); // Amarillo
                
                // Recorrer quads y crear bordes únicos
                const edgeSet = new Set();
                
                engine.quads.forEach(q => {
                    for(let i=0; i<4; i++) {
                        const i1 = q[i];
                        const i2 = q[(i+1)%4];
                        const key = i1<i2 ? `${i1}_${i2}` : `${i2}_${i1}`;
                        
                        if(edgeSet.has(key)) continue;
                        edgeSet.add(key);

                        const v1 = engine.vertices[i1];
                        const v2 = engine.vertices[i2];
                        const dist = v1.distanceTo(v2);
                        
                        const h = new THREE.Mesh(geo, mat);
                        h.position.copy(v1).add(v2).multiplyScalar(0.5);
                        h.lookAt(v2);
                        h.scale.z = dist * 0.7; // Visual gap
                        h.userData = { type: 'edge', v1: i1, v2: i2 };
                        helperGroup.add(h);
                    }
                });
            }
            else if(currentMode === 'face') {
                const geo = new THREE.PlaneGeometry(0.3, 0.3);
                const mat = new THREE.MeshBasicMaterial({ color: 0x3498db, side: THREE.DoubleSide, transparent:true, opacity:0.6 });
                const selMat = new THREE.MeshBasicMaterial({ color: 0xf1c40f, side: THREE.DoubleSide });

                engine.quads.forEach((q, i) => {
                    const center = new THREE.Vector3().add(engine.vertices[q[0]]).add(engine.vertices[q[1]]).add(engine.vertices[q[2]]).add(engine.vertices[q[3]]).multiplyScalar(0.25);
                    
                    // Normal aprox
                    const v0 = engine.vertices[q[0]];
                    const v1 = engine.vertices[q[1]];
                    const v2 = engine.vertices[q[3]]; // Usar v3 para normal correcta
                    const n = new THREE.Vector3().subVectors(v1, v0).cross(new THREE.Vector3().subVectors(v2, v0)).normalize();

                    const h = new THREE.Mesh(geo, mat);
                    h.position.copy(center);
                    h.lookAt(center.clone().add(n));
                    h.userData = { type: 'face', index: i };
                    helperGroup.add(h);
                });
            }
        }

        // ==========================================
        // 4. INTERACCIÓN Y TRANSFORMACIÓN
        // ==========================================
        const orbit = new OrbitControls(camera, renderer.domElement);
        orbit.enableDamping = true;
        
        const transform = new TransformControls(camera, renderer.domElement);
        transform.setSpace('local');
        transform.addEventListener('dragging-changed', e => orbit.enabled = !e.value);
        scene.add(transform);

        // LÓGICA DE MOVIMIENTO (Sincronizar Gizmo -> Motor Quad)
        transform.addEventListener('objectChange', () => {
            const h = transform.object;
            const type = h.userData.type;

            if(type === 'vertex') {
                // Actualizar 1 vértice
                const idx = h.userData.index;
                engine.vertices[idx].copy(h.position);
            } 
            else if(type === 'edge') {
                // Actualizar 2 vértices (Borde)
                const v1 = engine.vertices[h.userData.v1];
                const v2 = engine.vertices[h.userData.v2];
                // Calcular nueva posición relativa
                // Truco: Mover v1 y v2 basándonos en el offset del handle
                // (Para simplificar demo: Recalculamos desde el centro del handle)
                const dist = v1.distanceTo(v2);
                const dir = new THREE.Vector3().subVectors(v2, v1).normalize();
                
                // Reconstruir posiciones basadas en el handle (centro)
                v1.copy(h.position).addScaledVector(dir, -dist/2);
                v2.copy(h.position).addScaledVector(dir, dist/2);
            }
            else if(type === 'face') {
                // Actualizar 4 vértices (Cara)
                // Esto es complejo sin guardar offsets.
                // Implementación SIMPLE: Solo permitir mover caras para extruir en este demo,
                // O usar el delta de posición si estuviera disponible.
                
                // Hack: Para mover una cara, movemos sus 4 vértices igual.
                // Necesitamos la posición anterior... que no tenemos fácil.
                // SOLUCIÓN: Regeneramos handles al soltar. Mientras arrastras, 
                // la geometría visual puede no actualizarse perfectamente suave en modo cara
                // a menos que calculemos deltas.
                
                // Para esta versión robusta: Bloqueamos movimiento directo de cara (usar vértices/bordes para afinar)
                // La cara es principalmente para EXTRUIR.
            }

            updateGeometry();
            // No regeneramos handles durante el drag para rendimiento
        });

        // Al soltar, regenerar todo para asegurar consistencia
        transform.addEventListener('mouseUp', () => {
            if(currentMode !== 'vertex') rebuildHandles(); // Recalcular centros de bordes/caras
        });

        // ==========================================
        // 5. INPUTS
        // ==========================================
        
        // Raycaster
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.addEventListener('pointerdown', e => {
            if(e.target.closest('.toolbar')) return;

            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObjects(helperGroup.children);

            if(hits.length > 0) {
                const h = hits[0].object;
                selection = h;
                transform.attach(h);
                
                // Feedback visual de selección
                helperGroup.children.forEach(c => c.material.color.setHex( 
                    c.userData.type === 'vertex' ? 0xe74c3c : 
                    c.userData.type === 'edge' ? 0xf1c40f : 0x3498db 
                ));
                h.material.color.setHex(0xffffff); // Blanco seleccionado
            } else if (!transform.dragging) {
                transform.detach();
                selection = null;
            }
        });

        // UI Buttons
        function setMode(m) {
            currentMode = m;
            document.querySelectorAll('#top-bar .btn').forEach(b => b.classList.remove('active'));
            document.querySelector(`.btn[data-mode="${m}"]`).classList.add('active');
            
            // Toggle Extrude button availability
            document.getElementById('btn-extrude').style.opacity = (m === 'face' ? 1 : 0.3);
            
            rebuildHandles();
            updateGeometry();
        }

        document.querySelectorAll('.btn[data-mode]').forEach(b => {
            b.onclick = () => setMode(b.dataset.mode);
        });

        // Herramientas
        document.getElementById('btn-extrude').onclick = () => {
            if(currentMode === 'face' && selection) {
                engine.extrudeFace(selection.userData.index);
                updateGeometry();
                rebuildHandles();
            } else {
                alert("Selecciona una CARA para extruir");
            }
        };

        document.getElementById('btn-subdivide').onclick = () => {
            transform.detach();
            engine.subdivide();
            updateGeometry();
            rebuildHandles();
        };

        document.getElementById('btn-delete').onclick = () => {
            if(currentMode === 'face' && selection) {
                engine.deleteFace(selection.userData.index);
                transform.detach();
                updateGeometry();
                rebuildHandles();
            }
        };

        // Init
        updateGeometry();
        rebuildHandles();

        // Loop
        function animate() {
            requestAnimationFrame(animate);
            orbit.update();
            renderer.render(scene, camera);
        }
        animate();

        window.onresize = () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };
    </script>
</body>
</html>

