<!DOCTYPE html>

<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Blender Lite Pro - Enhanced UX</title>
    <style>
        * { box-sizing: border-box; }
        body { 
            margin: 0; overflow: hidden; background-color: #1a1a1a; 
            font-family: 'Segoe UI', sans-serif; touch-action: none; 
        }

```
    /* UI SUPERIOR */
    #top-bar {
        position: absolute; top: 15px; left: 50%; transform: translateX(-50%);
        display: flex; gap: 10px; background: rgba(30,30,30,0.95); padding: 10px 16px;
        border-radius: 12px; border: 1px solid #444; backdrop-filter: blur(10px);
        box-shadow: 0 4px 20px rgba(0,0,0,0.6); z-index: 100;
        flex-wrap: wrap; max-width: 90vw;
    }

    /* UI LATERAL DERECHA */
    #side-controls {
        position: absolute; right: 20px; top: 50%; transform: translateY(-50%);
        display: flex; flex-direction: column; gap: 12px; z-index: 100;
    }

    .btn {
        width: 48px; height: 48px; border: none; border-radius: 10px; background: #3a3a3a;
        color: #aaa; cursor: pointer; display: flex; align-items: center; justify-content: center;
        transition: 0.2s; position: relative; font-size: 10px; font-weight: bold;
        box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    }
    .btn:active { transform: scale(0.95); }
    .btn.active { background: #3498db; color: white; box-shadow: 0 0 16px rgba(52, 152, 219, 0.6); }
    
    .btn svg { width: 26px; height: 26px; fill: currentColor; }

    /* Colores por modo */
    .btn[data-mode="vertex"].active { background: #e74c3c; box-shadow: 0 0 16px rgba(231, 76, 60, 0.6); }
    .btn[data-mode="edge"].active { background: #f1c40f; color: #111; box-shadow: 0 0 16px rgba(241, 196, 15, 0.6); }
    .btn[data-mode="face"].active { background: #3498db; box-shadow: 0 0 16px rgba(52, 152, 219, 0.6); }
    
    /* Botones de Acci√≥n - UI Inferior */
    #bottom-bar {
        position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
        display: flex; gap: 12px; background: rgba(30,30,30,0.95); padding: 12px 20px;
        border-radius: 14px; border: 1px solid #444; backdrop-filter: blur(10px);
        box-shadow: 0 8px 30px rgba(0,0,0,0.7); z-index: 100;
    }

    .action-btn { 
        padding: 0 20px; height: 52px; font-weight: bold; font-size: 12px; 
        text-transform: uppercase; display: flex; align-items: center; gap: 8px;
        border-radius: 10px; transition: 0.2s;
    }
    .action-btn svg { width: 22px; height: 22px; }
    
    #btn-extrude { background: #f39c12; color: #fff; }
    #btn-extrude:active { background: #e67e22; }
    
    #btn-subdivide { background: #27ae60; color: #fff; }
    #btn-subdivide:active { background: #229954; }
    
    #btn-delete { background: #e74c3c; color: #fff; }
    #btn-delete:active { background: #c0392b; }

    /* Toggle SubSurf */
    .toggle-container {
        display: flex; align-items: center; gap: 10px; padding: 0 12px;
        background: rgba(50,50,50,0.9); border-radius: 10px; height: 52px;
    }
    .toggle-container label { color: #aaa; font-size: 11px; white-space: nowrap; font-weight: 600; }
    
    .switch {
        position: relative; width: 52px; height: 28px; background: #555;
        border-radius: 14px; cursor: pointer; transition: 0.3s;
        box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
    }
    .switch.active { background: #27ae60; }
    .switch::after {
        content: ''; position: absolute; width: 24px; height: 24px;
        background: white; border-radius: 50%; top: 2px; left: 2px;
        transition: 0.3s; box-shadow: 0 2px 6px rgba(0,0,0,0.4);
    }
    .switch.active::after { left: 26px; }

    /* Info Overlay */
    #info-overlay {
        position: absolute; top: 80px; width: 100%; text-align: center;
        color: #888; font-size: 12px; pointer-events: none; text-shadow: 0 1px 3px black;
        font-weight: 500;
    }
    
    #warning {
        position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);
        background: rgba(231, 76, 60, 0.95); color: white; padding: 20px 30px;
        border-radius: 12px; display: none; pointer-events: none; font-weight: bold;
        z-index: 250; box-shadow: 0 8px 30px rgba(0,0,0,0.8);
    }

    /* Medidor de Distancia Mejorado */
    #distance-display {
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        background: rgba(52, 152, 219, 0.95); color: white; padding: 18px 30px;
        border-radius: 12px; font-size: 20px; font-weight: bold;
        display: none; pointer-events: none; z-index: 150;
        box-shadow: 0 6px 25px rgba(0,0,0,0.6);
        border: 2px solid rgba(255,255,255,0.3);
    }
    #distance-display.active { display: block; }
    #distance-display .label {
        font-size: 11px; opacity: 0.8; margin-bottom: 4px;
    }

    /* Modal Controles de C√°mara */
    #camera-modal {
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        background: rgba(30,30,30,0.98); padding: 30px 40px; border-radius: 16px;
        border: 2px solid #3498db; display: none; z-index: 200;
        box-shadow: 0 10px 50px rgba(0,0,0,0.9);
    }
    #camera-modal.active { display: block; }
    #camera-modal h3 { 
        margin: 0 0 8px 0; color: #3498db; text-align: center; 
        font-size: 18px; display: flex; align-items: center; justify-content: center; gap: 10px;
    }
    #camera-modal p { 
        color: #aaa; margin: 0 0 25px 0; text-align: center; font-size: 13px; 
    }
    
    .camera-controls {
        display: flex; gap: 15px; justify-content: center; margin-bottom: 25px;
    }
    
    .camera-btn {
        width: 64px; height: 64px; border-radius: 50%; background: rgba(52, 152, 219, 0.3);
        border: 3px solid #3498db; color: #3498db; font-size: 28px;
        display: flex; align-items: center; justify-content: center;
        cursor: pointer; transition: 0.2s; box-shadow: 0 4px 15px rgba(0,0,0,0.4);
    }
    .camera-btn:active { transform: scale(0.9); }
    .camera-btn.active { 
        background: #27ae60; border-color: #27ae60; color: white;
        box-shadow: 0 0 20px rgba(39, 174, 96, 0.6);
    }

    .modal-actions {
        display: flex; gap: 15px; justify-content: center;
    }
    .modal-btn {
        padding: 14px 30px; border: none; border-radius: 10px;
        font-weight: bold; font-size: 13px; cursor: pointer;
        transition: 0.2s; text-transform: uppercase;
    }
    #btn-continue { background: #27ae60; color: white; }
    #btn-continue:active { background: #229954; }
    #btn-finish { background: #e74c3c; color: white; }
    #btn-finish:active { background: #c0392b; }

    .divider { width: 1px; background: #555; height: 40px; margin: 0 8px; }

    /* Flecha de medici√≥n 3D */
    .measurement-arrow {
        position: absolute;
        pointer-events: none;
        z-index: 140;
    }
</style>
```

</head>
<body>

```
<div id="info-overlay">
    <span id="mode-info">Modo V√©rtice ‚Ä¢ Selecci√≥n: Individual</span> ‚Ä¢ 
    <span id="poly-display">6</span> Caras ‚Ä¢ 
    <span id="subsurf-info">SubSurf: OFF</span>
</div>

<div id="warning">¬°L√≠mite de geometr√≠a alcanzado!</div>

<div id="distance-display">
    <div class="label">DESPLAZAMIENTO</div>
    <div id="distance-value">0.000 units</div>
</div>

<!-- Modal de Controles -->
<div id="camera-modal">
    <h3>üéØ Editando Geometr√≠a</h3>
    <p>Activa controles temporales de c√°mara</p>
    
    <div class="camera-controls">
        <div class="camera-btn" id="btn-rotate" title="Rotar con 1 dedo">üîÑ</div>
        <div class="camera-btn" id="btn-pan" title="Paneo con 2 dedos">‚úã</div>
        <div class="camera-btn" id="btn-zoom" title="Zoom con pellizco">üîç</div>
    </div>
    
    <div class="modal-actions">
        <button class="modal-btn" id="btn-continue">‚úì Continuar</button>
        <button class="modal-btn" id="btn-finish">‚úï Finalizar</button>
    </div>
</div>

<!-- UI Superior: Modos -->
<div id="top-bar">
    <button class="btn active" data-mode="vertex" title="V√©rtices">
        <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="5"/></svg>
    </button>
    <button class="btn" data-mode="edge" title="Bordes">
        <svg viewBox="0 0 24 24"><path d="M4 20L20 4" stroke="currentColor" stroke-width="4" stroke-linecap="round"/></svg>
    </button>
    <button class="btn" data-mode="face" title="Caras">
        <svg viewBox="0 0 24 24"><rect x="5" y="5" width="14" height="14" rx="2"/></svg>
    </button>
    
    <div class="divider"></div>
    
    <button class="btn" id="btn-select-mode" title="Modo Selecci√≥n">
        <svg viewBox="0 0 24 24">
            <rect x="3" y="3" width="7" height="7"/>
            <rect x="13" y="3" width="7" height="7"/>
            <rect x="3" y="13" width="7" height="7"/>
        </svg>
    </button>
</div>

<!-- UI Inferior: Acciones -->
<div id="bottom-bar">
    <button class="btn action-btn" id="btn-extrude">
        <svg viewBox="0 0 24 24"><path d="M4 4h16v16H4z M8 8h8v8H8z"/></svg>
        Extruir
    </button>
    <button class="btn action-btn" id="btn-subdivide">
        <svg viewBox="0 0 24 24"><path d="M3 3h18v18H3z M12 3v18 M3 12h18"/></svg>
        Dividir
    </button>
    
    <div class="divider"></div>
    
    <div class="toggle-container">
        <label>SubSurf</label>
        <div class="switch" id="toggle-subsurf"></div>
    </div>
    
    <div class="divider"></div>
    
    <button class="btn action-btn" id="btn-delete">
        <svg viewBox="0 0 24 24">
            <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>
        </svg>
        Borrar
    </button>
</div>

<script type="importmap">
{
    "imports": {
        "three": "https://ga.jspm.io/npm:three@0.160.0/build/three.module.js",
        "three/addons/": "https://ga.jspm.io/npm:three@0.160.0/examples/jsm/"
    }
}
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { TransformControls } from 'three/addons/controls/TransformControls.js';

    // ==========================================
    // CONFIGURACI√ìN GLOBAL
    // ==========================================
    let isMultiSelect = false;
    let selectedObjects = [];
    let isEditing = false;
    let initialPositions = new Map();
    let cameraMode = null;
    let subsurfEnabled = false;
    let subsurfLevel = 2;
    let isExtruding = false;
    let initialCameraDistance = 0;

    // Sistema de medici√≥n 3D
    let measurementArrow = null;
    let measurementOrigin = new THREE.Vector3();

    // ==========================================
    // MOTOR QUAD
    // ==========================================
    class QuadEngine {
        constructor() {
            this.vertices = []; 
            this.quads = [];
            this.baseVertices = [];
            this.baseQuads = [];
        }

        initCube() {
            this.vertices = []; this.quads = [];
            const s = 1; 
            const v = [[-s,-s,s],[s,-s,s],[s,s,s],[-s,s,s],[-s,-s,-s],[s,-s,-s],[s,s,-s],[-s,s,-s]];
            v.forEach(p => this.vertices.push(new THREE.Vector3(...p)));
            this.addQuad(0,1,2,3); this.addQuad(5,4,7,6); this.addQuad(1,5,6,2);
            this.addQuad(4,0,3,7); this.addQuad(3,2,6,7); this.addQuad(4,5,1,0);
            this.saveBase();
        }

        saveBase() {
            this.baseVertices = this.vertices.map(v => v.clone());
            this.baseQuads = this.quads.map(q => [...q]);
        }

        addQuad(a,b,c,d) { this.quads.push([a,b,c,d]); }

        getRenderData() {
            const positions = [];
            for(let q of this.quads) {
                const v = q.map(i => this.vertices[i]);
                if(!v[0] || !v[1] || !v[2] || !v[3]) continue;
                positions.push(v[0].x, v[0].y, v[0].z, v[1].x, v[1].y, v[1].z, v[2].x, v[2].y, v[2].z);
                positions.push(v[0].x, v[0].y, v[0].z, v[2].x, v[2].y, v[2].z, v[3].x, v[3].y, v[3].z);
            }
            return new Float32Array(positions);
        }

        getWireframeData() {
            const positions = [];
            for(let q of this.quads) {
                const v = q.map(i => this.vertices[i]);
                if(!v[0]) continue;
                for(let i=0; i<4; i++) {
                    const vCurr = v[i];
                    const vNext = v[(i+1)%4];
                    if(!vCurr || !vNext) continue;
                    positions.push(vCurr.x, vCurr.y, vCurr.z);
                    positions.push(vNext.x, vNext.y, vNext.z);
                }
            }
            return new Float32Array(positions);
        }

        subdivide() {
            if(this.quads.length > 2000) {
                showWarning();
                return;
            }

            const newQuads = [];
            const edgeCache = new Map();

            const getMid = (i1, i2) => {
                const key = i1<i2 ? `${i1}_${i2}` : `${i2}_${i1}`;
                if(edgeCache.has(key)) return edgeCache.get(key);
                
                const v1 = this.vertices[i1];
                const v2 = this.vertices[i2];
                if(!v1 || !v2) return null;
                
                const mid = new THREE.Vector3().addVectors(v1, v2).multiplyScalar(0.5);
                this.vertices.push(mid);
                const idx = this.vertices.length-1;
                edgeCache.set(key, idx);
                return idx;
            };

            for(let q of this.quads) {
                if(q.some(i => i >= this.vertices.length || !this.vertices[i])) continue;
                
                const v = q.map(i => this.vertices[i]);
                const centerPos = new THREE.Vector3().add(v[0]).add(v[1]).add(v[2]).add(v[3]).multiplyScalar(0.25);
                
                this.vertices.push(centerPos);
                const cIdx = this.vertices.length - 1;

                const m01 = getMid(q[0], q[1]);
                const m12 = getMid(q[1], q[2]);
                const m23 = getMid(q[2], q[3]);
                const m30 = getMid(q[3], q[0]);

                if(m01 === null || m12 === null || m23 === null || m30 === null) continue;

                newQuads.push([q[0], m01, cIdx, m30]);
                newQuads.push([m01, q[1], m12, cIdx]);
                newQuads.push([cIdx, m12, q[2], m23]);
                newQuads.push([m30, cIdx, m23, q[3]]);
            }
            this.quads = newQuads;
            this.saveBase();
        }

        applySubdivisionSurface(levels) {
            this.vertices = this.baseVertices.map(v => v.clone());
            this.quads = this.baseQuads.map(q => [...q]);

            for(let level = 0; level < levels; level++) {
                const newVertices = [];
                const newQuads = [];
                const edgePoints = new Map();
                const facePoints = [];
                
                for(let q of this.quads) {
                    const v = q.map(i => this.vertices[i]);
                    const fp = new THREE.Vector3().add(v[0]).add(v[1]).add(v[2]).add(v[3]).multiplyScalar(0.25);
                    facePoints.push(fp);
                }

                const getEdgePoint = (i1, i2, adjacentFaces) => {
                    const key = i1<i2 ? `${i1}_${i2}` : `${i2}_${i1}`;
                    if(edgePoints.has(key)) return edgePoints.get(key);

                    const v1 = this.vertices[i1];
                    const v2 = this.vertices[i2];
                    const mid = new THREE.Vector3().addVectors(v1, v2).multiplyScalar(0.5);
                    
                    if(adjacentFaces.length > 0) {
                        adjacentFaces.forEach(fIdx => mid.add(facePoints[fIdx]));
                        mid.divideScalar(adjacentFaces.length + 1);
                    }

                    const idx = newVertices.length;
                    newVertices.push(mid);
                    edgePoints.set(key, idx);
                    return idx;
                };

                const vertexMapping = new Map();
                this.vertices.forEach((v, i) => {
                    const adjacentFaces = [];
                    const adjacentEdges = [];
                    
                    this.quads.forEach((q, qIdx) => {
                        if(q.includes(i)) {
                            adjacentFaces.push(qIdx);
                            const idx = q.indexOf(i);
                            const prev = q[(idx + 3) % 4];
                            const next = q[(idx + 1) % 4];
                            if(!adjacentEdges.some(e => e.includes(prev))) adjacentEdges.push([i, prev]);
                            if(!adjacentEdges.some(e => e.includes(next))) adjacentEdges.push([i, next]);
                        }
                    });

                    const n = adjacentFaces.length;
                    if(n === 0) {
                        vertexMapping.set(i, newVertices.length);
                        newVertices.push(v.clone());
                        return;
                    }

                    const F = new THREE.Vector3();
                    adjacentFaces.forEach(fIdx => F.add(facePoints[fIdx]));
                    F.divideScalar(n);

                    const R = new THREE.Vector3();
                    adjacentEdges.forEach(([i1, i2]) => {
                        R.add(this.vertices[i1]).add(this.vertices[i2]);
                    });
                    R.divideScalar(adjacentEdges.length * 2);

                    const newV = new THREE.Vector3();
                    newV.addScaledVector(F, 1);
                    newV.addScaledVector(R, 2);
                    newV.addScaledVector(v, n - 3);
                    newV.divideScalar(n);

                    vertexMapping.set(i, newVertices.length);
                    newVertices.push(newV);
                });

                this.quads.forEach((q, qIdx) => {
                    const fp = facePoints[qIdx];
                    const fpIdx = newVertices.length;
                    newVertices.push(fp);

                    for(let i = 0; i < 4; i++) {
                        const curr = q[i];
                        const next = q[(i + 1) % 4];
                        
                        const vCurr = vertexMapping.get(curr);
                        const ep = getEdgePoint(curr, next, [qIdx]);
                        const vNext = vertexMapping.get(next);
                        const epPrev = getEdgePoint(q[(i + 3) % 4], curr, [qIdx]);

                        newQuads.push([vCurr, ep, fpIdx, epPrev]);
                    }
                });

                this.vertices = newVertices;
                this.quads = newQuads;
            }
        }

        extrudeFace(index) {
            if(index < 0 || index >= this.quads.length) return;
            const q = this.quads[index];
            
            if(q.some(i => i >= this.vertices.length || !this.vertices[i])) return;
            
            const v = q.map(i => this.vertices[i]);
            const vA = new THREE.Vector3().subVectors(v[1], v[0]);
            const vB = new THREE.Vector3().subVectors(v[3], v[0]);
            const normal = new THREE.Vector3().crossVectors(vA, vB).normalize();
            
            const topIndices = [];
            const dist = 0.5;

            for(let i=0; i<4; i++) {
                const newPos = v[i].clone().add(normal.clone().multiplyScalar(dist));
                this.vertices.push(newPos);
                topIndices.push(this.vertices.length-1);
            }

            const base = [...q];
            for(let i=0; i<4; i++) {
                const next = (i+1)%4;
                this.addQuad(base[i], base[next], topIndices[next], topIndices[i]);
            }

            this.quads[index] = topIndices;
            this.saveBase();
            return index;
        }

        deleteFace(index) {
            if(index > -1 && index < this.quads.length) {
                this.quads.splice(index, 1);
                this.saveBase();
            }
        }
    }

    // ==========================================
    // ESCENA
    // ==========================================
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1a1a1a);
    scene.add(new THREE.GridHelper(20, 20, 0x444444, 0x2a2a2a));

    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(5, 5, 5);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    const light = new THREE.DirectionalLight(0xffffff, 1.5);
    light.position.set(5, 10, 7);
    scene.add(light, new THREE.AmbientLight(0xffffff, 0.5));

    const engine = new QuadEngine();
    engine.initCube();

    let mainMesh = new THREE.Mesh(new THREE.BufferGeometry(), new THREE.MeshStandardMaterial({ 
        color: 0x7f8c8d, roughness: 0.5, metalness: 0.1, polygonOffset: true, polygonOffsetFactor: 1 
    }));
    scene.add(mainMesh);

    let wireMesh = new THREE.LineSegments(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ 
        color: 0x0a0a0a, opacity: 0.6, transparent: true 
    }));
    scene.add(wireMesh);

    let cageMesh = new THREE.LineSegments(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ 
        color: 0x3498db, opacity: 0.7, transparent: true, linewidth: 2
    }));
    scene.add(cageMesh);

    // Flecha de medici√≥n 3D
    function createMeasurementArrow() {
        const dir = new THREE.Vector3(0, 1, 0);
        const origin = new THREE.Vector3(0, 0, 0);
        const length = 1;
        const hex = 0xff6b6b;
        
        const arrow = new THREE.ArrowHelper(dir, origin, length, hex, 0.3, 0.2);
        arrow.visible = false;
        scene.add(arrow);
        return arrow;
    }

    measurementArrow = createMeasurementArrow();

    function updateMeasurementArrow(currentPos) {
        const distance = currentPos.distanceTo(measurementOrigin);
        if(distance < 0.01) {
            measurementArrow.visible = false;
            return;
        }

        const direction = new THREE.Vector3().subVectors(currentPos, measurementOrigin).normalize();
        measurementArrow.position.copy(measurementOrigin);
        measurementArrow.setDirection(direction);
        measurementArrow.setLength(distance, distance * 0.15, distance * 0.1);
        measurementArrow.visible = true;
    }

    function updateScene() {
        mainMesh.geometry.dispose();
        wireMesh.geometry.dispose();
        cageMesh.geometry.dispose();

        if(subsurfEnabled) {
            engine.applySubdivisionSurface(subsurfLevel);
        }

        const renderData = engine.getRenderData();
        const wireData = engine.getWireframeData();

        const newMainGeo = new THREE.BufferGeometry();
        newMainGeo.setAttribute('position', new THREE.BufferAttribute(renderData, 3));
        newMainGeo.computeVertexNormals();
        mainMesh.geometry = newMainGeo;

        const newWireGeo = new THREE.BufferGeometry();
        newWireGeo.setAttribute('position', new THREE.BufferAttribute(wireData, 3));
        wireMesh.geometry = newWireGeo;

        if(subsurfEnabled) {
            const baseCopy = new QuadEngine();
            baseCopy.vertices = engine.baseVertices.map(v => v.clone());
            baseCopy.quads = engine.baseQuads.map(q => [...q]);
            const cageData = baseCopy.getWireframeData();
            
            const newCageGeo = new THREE.BufferGeometry();
            newCageGeo.setAttribute('position', new THREE.BufferAttribute(cageData, 3));
            cageMesh.geometry = newCageGeo;
            cageMesh.visible = true;
        } else {
            cageMesh.visible = false;
        }

        document.getElementById('poly-display').innerText = engine.baseQuads.length;
    }

    // ==========================================
    // HANDLES
    // ==========================================
    const helperGroup = new THREE.Group();
    scene.add(helperGroup);
    let currentMode = 'vertex';

    function rebuildHandles() {
        helperGroup.clear();
        selectedObjects = [];
        transform.detach();

        const verts = subsurfEnabled ? engine.baseVertices : engine.vertices;
        const quads = subsurfEnabled ? engine.baseQuads : engine.quads;

        if(verts.length > 3000 && currentMode !== 'face') return;

        if(currentMode === 'vertex') {
            const geo = new THREE.SphereGeometry(0.12);
            const mat = new THREE.MeshBasicMaterial({ color: 0xe74c3c });
            verts.forEach((v, i) => {
                if(!v) return;
                const h = new THREE.Mesh(geo, mat);
                h.position.copy(v);
                h.userData = { type: 'vertex', index: i };
                helperGroup.add(h);
            });
        } else if (currentMode === 'face') {
            const geo = new THREE.PlaneGeometry(0.25, 0.25);
            const mat = new THREE.MeshBasicMaterial({ color: 0x3498db, side: THREE.DoubleSide, depthTest: false });
            
            quads.forEach((q, i) => {
                if(q.some(idx => idx >= verts.length || !verts[idx])) return;
                
                const center = new THREE.Vector3();
                q.forEach(idx => center.add(verts[idx]));
                center.multiplyScalar(0.25);
                
                const v0 = verts[q[0]];
                const v1 = verts[q[1]];
                const v2 = verts[q[3]];
                const n = new THREE.Vector3().subVectors(v1, v0).cross(new THREE.Vector3().subVectors(v2, v0)).normalize();

                const h = new THREE.Mesh(geo, mat);
                h.position.copy(center);
                h.lookAt(center.clone().add(n));
                h.userData = { type: 'face', index: i };
                helperGroup.add(h);
            });
        } else if (currentMode === 'edge') {
            const geo = new THREE.BoxGeometry(0.06, 0.06, 1);
            const mat = new THREE.MeshBasicMaterial({ color: 0xf1c40f });
            const processed = new Set();

            quads.forEach(q => {
                for(let k=0; k<4; k++) {
                    const i1 = q[k];
                    const i2 = q[(k+1)%4];
                    
                    if(i1 >= verts.length || i2 >= verts.length) continue;
                    if(!verts[i1] || !verts[i2]) continue;
                    
                    const key = i1<i2 ? `${i1}_${i2}` : `${i2}_${i1}`;
                    if(processed.has(key)) continue;
                    processed.add(key);

                    const v1 = verts[i1];
                    const v2 = verts[i2];
                    const dist = v1.distanceTo(v2);
                    
                    const h = new THREE.Mesh(geo, mat);
                    h.position.copy(v1).add(v2).multiplyScalar(0.5);
                    h.lookAt(v2);
                    h.scale.z = dist * 0.6;
                    h.userData = { type: 'edge', v1: i1, v2: i2 };
                    helperGroup.add(h);
                }
            });
        }
    }

    // ==========================================
    // CONTROLES
    // ==========================================
    const orbit = new OrbitControls(camera, renderer.domElement);
    orbit.enableDamping = true;
    orbit.dampingFactor = 0.05;
    
    // Configuraci√≥n t√°ctil por defecto
    orbit.touches = {
        ONE: THREE.TOUCH.ROTATE,
        TWO: THREE.TOUCH.DOLLY_PAN
    };

    const transform = new TransformControls(camera, renderer.domElement);
    transform.setSpace('local');
    
    transform.addEventListener('dragging-changed', e => {
        if(e.value) {
            // Al comenzar a arrastrar
            orbit.enabled = false;
            if(cameraMode) {
                // Si hay un modo de c√°mara activo, permitir ambos
                orbit.enabled = true;
            }
        } else {
            // Al soltar
            if(isEditing) {
                showCameraModal();
            } else {
                // Restaurar controles normales
                enableNormalControls();
            }
        }
    });

    function enableNormalControls() {
        orbit.enabled = true;
        orbit.enableRotate = true;
        orbit.enablePan = true;
        orbit.enableZoom = true;
        orbit.touches = {
            ONE: THREE.TOUCH.ROTATE,
            TWO: THREE.TOUCH.DOLLY_PAN
        };
    }

    // Medici√≥n
    transform.addEventListener('mouseDown', () => {
        initialPositions.clear();
        
        if(selectedObjects.length > 0) {
            const h = selectedObjects[0];
            measurementOrigin.copy(h.position);
            
            selectedObjects.forEach(obj => {
                initialPositions.set(obj, obj.position.clone());
            });

            // Guardar distancia inicial de c√°mara
            initialCameraDistance = camera.position.length();
        }
    });

    transform.addEventListener('objectChange', () => {
        const h = transform.object;
        if(!h || !h.userData) return;
        
        const type = h.userData.type;
        const verts = subsurfEnabled ? engine.baseVertices : engine.vertices;

        if(type === 'vertex') {
            if(isMultiSelect) {
                const delta = new THREE.Vector3().subVectors(h.position, initialPositions.get(h));
                selectedObjects.forEach(obj => {
                    if(obj !== h && obj.userData.index < verts.length) {
                        const original = initialPositions.get(obj);
                        obj.position.copy(original).add(delta);
                        verts[obj.userData.index].copy(obj.position);
                    }
                });
            }
            if(h.userData.index < verts.length) {
                verts[h.userData.index].copy(h.position);
            }
        } else if (type === 'edge') {
            const v1Idx = h.userData.v1;
            const v2Idx = h.userData.v2;
            
            if(v1Idx >= verts.length || v2Idx >= verts.length) return;
            
            const v1 = verts[v1Idx];
            const v2 = verts[v2Idx];
            const dist = v1.distanceTo(v2);
            const dir = new THREE.Vector3().subVectors(v2, v1).normalize();
            v1.copy(h.position).addScaledVector(dir, -dist/2);
            v2.copy(h.position).addScaledVector(dir, dist/2);
        }

        // Actualizar flecha de medici√≥n
        updateMeasurementArrow(h.position);

        // Mostrar distancia
        if(initialPositions.has(h)) {
            const distance = h.position.distanceTo(measurementOrigin);
            document.getElementById('distance-value').innerText = `${distance.toFixed(3)} units`;
            document.getElementById('distance-display').classList.add('active');
        }

        // Auto-zoom suave durante edici√≥n
        if(isExtruding || transform.dragging) {
            const currentDistance = h.position.length();
            const targetDistance = Math.max(initialCameraDistance * 1.2, currentDistance * 1.5);
            const newDistance = THREE.MathUtils.lerp(camera.position.length(), targetDistance, 0.03);
            camera.position.setLength(newDistance);
        }

        updateScene();
    });

    transform.addEventListener('mouseUp', () => {
        document.getElementById('distance-display').classList.remove('active');
        measurementArrow.visible = false;
        isExtruding = false;
        
        if(currentMode !== 'vertex') rebuildHandles();
    });

    // ==========================================
    // UI EVENTS
    // ==========================================
    function setMode(m) {
        currentMode = m;
        document.querySelectorAll('.btn[data-mode]').forEach(b => b.classList.remove('active'));
        const modeBtn = document.querySelector(`.btn[data-mode="${m}"]`);
        if(modeBtn) modeBtn.classList.add('active');

        const modeNames = { vertex: 'V√©rtice', edge: 'Borde', face: 'Cara' };
        const selectMode = isMultiSelect ? 'M√∫ltiple' : 'Individual';
        document.getElementById('mode-info').innerText = `Modo ${modeNames[m]} ‚Ä¢ Selecci√≥n: ${selectMode}`;

        rebuildHandles();
        updateScene();
    }

    document.querySelectorAll('.btn[data-mode]').forEach(b => b.onclick = () => setMode(b.dataset.mode));

    document.getElementById('btn-select-mode').onclick = () => {
        isMultiSelect = !isMultiSelect;
        const btn = document.getElementById('btn-select-mode');
        btn.classList.toggle('active', isMultiSelect);
        
        const selectMode = isMultiSelect ? 'M√∫ltiple' : 'Individual';
        const modeNames = { vertex: 'V√©rtice', edge: 'Borde', face: 'Cara' };
        document.getElementById('mode-info').innerText = `Modo ${modeNames[currentMode]} ‚Ä¢ Selecci√≥n: ${selectMode}`;
    };

    document.getElementById('btn-extrude').onclick = () => {
        if(currentMode === 'face' && selectedObjects.length > 0) {
            isExtruding = true;
            selectedObjects.forEach(obj => {
                if(obj.userData.type === 'face') {
                    engine.extrudeFace(obj.userData.index);
                }
            });
            updateScene();
            rebuildHandles();
            setTimeout(() => { isExtruding = false; }, 1000);
        }
    };

    document.getElementById('btn-subdivide').onclick = () => {
        transform.detach();
        engine.subdivide();
        updateScene();
        rebuildHandles();
    };

    document.getElementById('btn-delete').onclick = () => {
        if(currentMode === 'face' && selectedObjects.length > 0) {
            const indices = selectedObjects.map(o => o.userData.index).sort((a,b) => b-a);
            indices.forEach(idx => engine.deleteFace(idx));
            transform.detach();
            updateScene();
            rebuildHandles();
        }
    };

    document.getElementById('toggle-subsurf').onclick = function() {
        subsurfEnabled = !subsurfEnabled;
        this.classList.toggle('active', subsurfEnabled);
        document.getElementById('subsurf-info').innerText = `SubSurf: ${subsurfEnabled ? 'ON' : 'OFF'}`;
        updateScene();
        rebuildHandles();
    };

    // Modal de C√°mara
    function showCameraModal() {
        document.getElementById('camera-modal').classList.add('active');
        isEditing = true;
        orbit.enabled = false;
    }

    function hideCameraModal() {
        document.getElementById('camera-modal').classList.remove('active');
        isEditing = false;
        cameraMode = null;
        updateCameraButtons();
        enableNormalControls();
    }

    document.getElementById('btn-continue').onclick = hideCameraModal;
    
    document.getElementById('btn-finish').onclick = () => {
        hideCameraModal();
        transform.detach();
        selectedObjects = [];
        helperGroup.children.forEach(c => resetHandleColor(c));
    };

    function updateCameraButtons() {
        document.querySelectorAll('.camera-btn').forEach(b => b.classList.remove('active'));
        
        orbit.enableRotate = false;
        orbit.enablePan = false;
        orbit.enableZoom = false;

        if(cameraMode === 'rotate') {
            document.getElementById('btn-rotate').classList.add('active');
            orbit.enabled = true;
            orbit.enableRotate = true;
        } else if(cameraMode === 'pan') {
            document.getElementById('btn-pan').classList.add('active');
            orbit.enabled = true;
            orbit.enablePan = true;
        } else if(cameraMode === 'zoom') {
            document.getElementById('btn-zoom').classList.add('active');
            orbit.enabled = true;
            orbit.enableZoom = true;
        } else {
            orbit.enabled = false;
        }
    }

    document.getElementById('btn-rotate').onclick = () => {
        cameraMode = cameraMode === 'rotate' ? null : 'rotate';
        updateCameraButtons();
    };

    document.getElementById('btn-pan').onclick = () => {
        cameraMode = cameraMode === 'pan' ? null : 'pan';
        updateCameraButtons();
    };

    document.getElementById('btn-zoom').onclick = () => {
        cameraMode = cameraMode === 'zoom' ? null : 'zoom';
        updateCameraButtons();
    };

    // ==========================================
    // RAYCASTER
    // ==========================================
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    window.addEventListener('pointerdown', e => {
        if(e.target.closest('#top-bar') || e.target.closest('#bottom-bar') || 
           e.target.closest('.camera-btn') || e.target.closest('#camera-modal')) return;

        const r = renderer.domElement.getBoundingClientRect();
        mouse.x = ((e.clientX - r.left)/r.width)*2-1;
        mouse.y = -((e.clientY - r.top)/r.height)*2+1;
        raycaster.setFromCamera(mouse, camera);

        const hits = raycaster.intersectObjects(helperGroup.children);
        if(hits.length > 0) {
            const hit = hits[0].object;

            if(isMultiSelect) {
                if(selectedObjects.includes(hit)) {
                    selectedObjects = selectedObjects.filter(o => o !== hit);
                    resetHandleColor(hit);
                } else {
                    selectedObjects.push(hit);
                    hit.material.color.setHex(0xffffff);
                }

                if(selectedObjects.length > 0) {
                    transform.attach(selectedObjects[0]);
                    initialPositions.clear();
                    selectedObjects.forEach(obj => {
                        initialPositions.set(obj, obj.position.clone());
                    });
                } else {
                    transform.detach();
                }
            } else {
                selectedObjects = [hit];
                transform.attach(hit);
                
                helperGroup.children.forEach(c => resetHandleColor(c));
                hit.material.color.setHex(0xffffff);
            }

            if(!isEditing && selectedObjects.length > 0) {
                showCameraModal();
            }
        } else if (!transform.dragging && !isEditing) {
            transform.detach();
            selectedObjects = [];
        }
    });

    function resetHandleColor(handle) {
        let col = 0xffffff;
        if(handle.userData.type === 'vertex') col = 0xe74c3c;
        if(handle.userData.type === 'edge') col = 0xf1c40f;
        if(handle.userData.type === 'face') col = 0x3498db;
        handle.material.color.setHex(col);
    }

    function showWarning() {
        document.getElementById('warning').style.display = 'block';
        setTimeout(() => document.getElementById('warning').style.display = 'none', 2000);
    }

    // ==========================================
    // INIT
    // ==========================================
    updateScene();
    rebuildHandles();

    function animate() {
        requestAnimationFrame(animate);
        orbit.update();
        renderer.render(scene, camera);
    }
    animate();

    window.onresize = () => {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    };
</script>
```

</body>
</html>
